\documentclass[14pt,aspectratio=169]{beamer} %aspectratio=169 %aspectratio=43 % trans erzeugt Folien ohne Overlay
\usepackage[ngerman]{babel}
\usepackage[ansinew]{luainputenc}
\usepackage{listings}
\usepackage{pgfpages} % Second screen
\setbeameroption{hide notes} % show notes on second screen=bottom % hide notes % show notes % show only notes
\setbeamerfont{note page}{size=\tiny}


% Some colors
\definecolor{hBlue}{HTML}{004C99}
\definecolor{hBlack}{HTML}{555555}
\definecolor{hHeaderRed}{HTML}{E32119}
\definecolor{hBgLightBlue}{HTML}{E9E9E9}
\definecolor{hDarkBlue}{HTML}{00264C}

\definecolor{mDarkBrown}{HTML}{604c38}
\definecolor{mDarkTeal}{HTML}{23373b}
\definecolor{mLightBrown}{HTML}{EB811B}
\definecolor{mLightGreen}{HTML}{14B03D}

% Some styles for listings
\lstset{tabsize=2}
\lstdefinestyle{customscala}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Scala,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Java,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}

\lstset{style=customscala}

\usetheme[progressbar=foot, 
					numbering=none, 
					background=light,
					block=transparent]{metropolis} % block:fill
\setsansfont[BoldFont={Fira Sans},ItalicFont={Fira Sans Light Italic}]{Fira Sans Light}
\metroset{sectionpage=none} %sectionpage=progressbar

\setbeamercolor{normal text}{fg=hBlue, bg=black!2}
\setbeamercolor{alerted text}{fg=hHeaderRed}
\setbeamercolor{example text}{fg=mLightGreen}
\setbeamercolor{titlelike}{use=normal text, parent=normal text}
\setbeamercolor{author}{use=normal text, parent=normal text}
\setbeamercolor{date}{use=normal text, parent=normal text}
\setbeamercolor{institute}{use=normal text, parent=normal text}
\setbeamercolor{structure}{use=normal text, fg=normal text.fg}
\setbeamercolor{palette primary}{use=normal text, fg=normal text.bg, bg=normal text.fg}
\setbeamercolor{frametitle}{use=palette primary, parent=palette primary}
\setbeamercolor{progress bar}{use=alerted text, fg=alerted text.fg, bg=alerted text.fg!50!black!30}
\setbeamercolor{title separator}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in head/foot}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in section page}{use=progress bar, parent=progress bar}
%block transparent
\setbeamercolor{block title}{use=normal text, fg=hBlack, bg=}
\setbeamercolor{block body}{bg= }
\setbeamercolor{block body alerted}{use=block body, parent=block body}
\setbeamercolor{block body example}{use=block body, parent=block body}
\setbeamercolor{footnote}{fg=normal text.fg!90}
\setbeamercolor{footnote mark}{fg=.}

%% End color definition

% Subsectionpage
\AtBeginSubsection{\frame{\subsectionpage}}

\defbeamertemplate{subsection page}{progressbar}{
  \centering
  \begin{minipage}{22em}
    \raggedright
    \usebeamercolor[fg]{section title}
    \usebeamerfont{section title}
    \insertsectionhead\\[-1ex]
    \usebeamertemplate*{progress bar in section page}
    \par
    \ifx\insertsubsection\@empty\else%
      \usebeamercolor[fg]{subsection title}%
      \usebeamerfont{subsection title}%
      \insertsubsection
    \fi
  \end{minipage}
  \par
  \vspace{\baselineskip}
}

\setbeamertemplate{subsection page}[progressbar]
% End Subsectionpage

\usepackage{appendixnumberbeamer}
\usepackage[scale=2]{ccicons}
\usepackage{xspace}

\title{Scala (Programmiersprache)}
\subtitle{Ein Teaser und allgemeinere Gedanken}
\date{16. März 2016}
\author{Sebastian Eidecker}

\begin{document}

\maketitle

\begin{frame}{}
  \begin{quote}
		{\large Wer als Werkzeug nur einen Hammer hat,\\sieht in jedem Problem einen Nagel.}
		\vskip3mm
		\hspace*\fill{\small--- Paul Watzlawick}
	\end{quote}
\end{frame}
\note{
	Ich möchte heute über Scala reden. Eigentlich will ich aber nicht nur über Scala reden.  Ich möchte nicht Scala verkaufen, sondern etwas völlig anderes. Scala ist spannend - für Nerds, die des Geldes wegen Java benutzen. Wir müssen aber auch über wichtigere Probleme reden. Und vielleicht passt Scala ja doch irgendwie.
	
In der IT wollen wir Probleme lösen und Möglichkeiten schaffen. 
Ich bin der festen Überzeugung, dass wir zu selten über den Kern unserer Probleme nachdenken und auch, dass sich diese Probleme gerade ändern und immer schneller ändern werden.

Ich glaube daher, dass wir unser Problem \alert{und} unseren Werkzeugkasten kennen müssen. Ich glaube, dass wir zumindest wissen müssen, was im Baumarkt ausliegt und wir bei Bedarf einkaufen können. Daher kann es aus meiner Sicht nie schaden, sich neue Werkzeuge und Arbeitsweisen anzuschauen, damit man sie bei Bedarf zumindest im Hinterkopf hat. Sonst kann es passieren, dass wir das Problem gar nicht verstehen, weil wir kein passendes Werkzeug dafür besitzen und verwenden können.}



\begin{frame}{}
	\setbeamertemplate{section in toc}[sections unnumbered]
	\begin{block}{Worüber reden wir?}
		\vskip2mm
		\onslide<1->{\tableofcontents[pausesections,pausesubsections]} %[hideallsubsections]}
	\end{block}
	\note{Deswegen, möchte ich über zwei Dinge reden: Neue Herausforderungen und Scala.}
\end{frame}


\section{IT im Wandel}


\subsection{Herausforderungen}

\begin{frame}{}
	\only<1>{\Large\textbf{Software Engineering}}\only<2>{\Large\textbf{Software \alert{Engineering}}}
	\note{Software Engineering. Passt der Begriff?}
\end{frame}


\begin{frame}{}
	\begin{block}{Forderungen an IT}
		\begin{itemize}
			\item<2->Stabilität und Resilienz
			\note<2>{Magnor: Sorgen sie durch ihre Arbeit dafür, dass Systeme Kriterien der Stabilität und Resilienz erfüllen.
			Seien sie "`dran"' an den Problemen, antizipieren sie sie, schaffen sie Fall-Back-Lösungen -- auch an Wochenenden.}
			\item<3->Wertbeitrag
			\note<3>{IT entwickelt sich zunehmend zu einem eigenen Produktionsfaktor (4-Sektor-Hypothese).
			Seien sie ein verlässlicher Partner für das Business, nehmen sie die Business-Seite auch an die Hand, helfen und unterstützen sie, leisten sie einen wahrgenommenen Wertbeitrag.[...]}
			\item<4->Businesstreiber
			\note<4>{Die Entwicklung der IT treibt zunehmend die Business-Seite und verändert Geschäftsmodelle.
			Seien sie an der Front und treiben sie das Business, entwickeln sie neue Ideen, forschen sie nach neuen Lösungen (Beispiele: Uber, 3D-Printing, CoLo21, ...}
		\end{itemize}
		\onslide<5->{\vskip3mm --- Matthias Magnor -- CEO Surface und Contract Logistics}
		\note<5->{Das Bewusstsein, dass ein Wandel stattfindet, ist im Business angekommen. Diese Forderungen stammen von Matthias Magnor!}
	\end{block}
\end{frame}


\subsection{Manifeste}
\note{Ein Manifest (lateinisch manifestus ‚handgreiflich gemacht‘) ist eine öffentliche Erklärung von Zielen und Absichten, oftmals politischer Natur. (Wikipedia)}

\begin{frame}{}
	\begin{block}{Manifeste}
		\begin{itemize}
			\item<1,4->Antwortbereit, Widerstandsfähig, Elastisch, Nachrichtenorientiert (2013)
			\item<2,4->Gut gefertigt, Stets Mehrwert, Gemeinschaft aus Experten, Produktive Partnerschaften (2009)
			\item<3,4->Individuen und Interaktionen, Funktionierende Software, Zusammenarbeit mit dem Kunden, Reagieren auf Veränderung (2001)
		\end{itemize}
	\end{block}
\end{frame}
\note{Es gibt Manifeste von Softwareentwicklern, die sehr Ähnliches aussagen. (Reaktives Manifest, agiles Manifest, Manifest der Software Craftmanship-Bewegung als Beispiele) Diese sind bekannt und -- ich habe zumindest das Gefühl -- auch anerkannt. Ich will auch nur sehr kurz darauf eingehen, es soll ja vor allem um Scala gehen.}

\begin{frame}{}
	\only<1->{\Large \textbf{Wo stehen wir}?}
\end{frame}


\section{Scala}

\subsection{Management Summary}

\begin{frame}{}
	\Large\textbf{\alert{Sca}}lable \textbf{\alert{La}}nguage
	\only<2->{
	\vskip3mm
	\begin{quote}
		{\normalsize This means that Scala grows with you. You can play with it by typing \alert{one-line expressions} and observing the results. But you can also rely on it for \alert{large mission critical systems} [...]}
		\vskip3mm
		\hspace*\fill{\small--- www.scala-lang.org}
	\end{quote}
	}
	\note{Was bedeutet das? Scala ist sehr flexibel. Es vereint sehr viele Konzepte und ist im API-Design sehr stark. So sollen unterschiedlichste Szenarien und Anforderungen bedient werden. Schauen wir, ob das Versprechen gehalten wird.}
\end{frame}


\begin{frame}{}
	\begin{block}{Eigenschaften}
		\begin{itemize}
			\item<2->Objektorientiert
			\note<2>{Keine Primitive, wie in Java. Ein schönes Beispiel: Dort hat man per Autoboxing Komplexität eingeführt statt Schönheit. NullPointer bei Primitiven anyone?}
			\item<3->Funktional
			\item<4->Statisch typisiert mit Type Inference
			\note<4>{Aber Type Inference, wenn gewünscht}
			\item<5->Immutable by default
			\item<6->Gewohnte Syntax ("`Java ohne Semikolon"')
			\item<7->Ausdrucksstark (APIs/DSLs)
			\note<7>{Bei Java bricht man sich schon die Hände, will man ein Builder-Pattern rekursiv umsetzen oder eine fluent API}
			\item<8->Jung (2004, Hype 2011)
		\end{itemize}
	\end{block}
\end{frame}
\note{}

\begin{frame}{}
	\begin{block}{Versprechen}
	\begin{itemize}
		\item<2->Produktivitätssteierung
		\item<3->Höhere Codequalität
		\item<4->Mehr Spaß
		\item[]<5->\alert{durch}
		\item<5->Weniger Code
		\item<6->Höheres Abstraktionsniveau
		\item<7->Skalierbarkeit
	\end{itemize}
	\end{block}
\end{frame}
\note{Passt in unseren Entwicklungsprozess.
Leichte Änderungen an Deployment etc.}

\begin{frame}{}
	\begin{block}{Scala und die Java-Plattform}
		\begin{itemize}
			\item<2->Java-Bytecode, läuft auf JVM
			\item<3->Java-Bibliotheken nutzbar
			\item<4->Bekannte IDEs
			\note<4,5>{Wenn man schon eine neue Sprache lernt, wird man wenigstens bei IDE und Buildprozess abgeholt.}
			\item<5->Ähnliches Toolset, oft wiederverwendbar
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\subsection{Ein wenig Code}
\note{Alles geklaut von Wikipedia oder Heiko Seebergers Buch}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<2->
  \begin{lstlisting}
public class Person {
	private final String firstName;
	private final String lastName;
	public Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
					}
	public String getFirstName() {
			return firstName;
	}
	public String getLastName() {
			return lastName;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=14]
	@Override
	public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Person person = (Person) o;
			if (firstName != null ? 
					!firstName.equals(person.firstName) : 
					person.firstName != null) return false;
			if (lastName != null ? 
					!lastName.equals(person.lastName) : 
					person.lastName != null) return false;
			return true;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=27]
	@Override
	public int hashCode() {
			int result = firstName != null ? firstName.hashCode() : 0;
			result = 
					31 * result + (lastName != null ? lastName.hashCode() : 0);
			return result;
	}
}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
	\Large\textbf{Businesslogik?}
	\note{Wo ist die Businesslogik versteckt? Ich gebe zu, das wird nur ein Beispiel, aber es zeigt symptomatisch eine Schwäche von Java: 
Java ist leicht verständlich, Änderungen werden aber immer non-breaking eingeführt und fühlen sich oft deplatziert an.
Scala hat den Vorteil, neuer zu sein und kennt die Schmerzen der Java-Entwickler. Daher sind viele Dinge eingebaut, die man sich schon lange wünscht 
oder Konzepte, die man eigentlich schon immer umsetzen wollte, wenn es denn nicht so lästig wäre.
(Immutable Objects, Lambdas, Generics, checked Exceptions als Beispiel)

Ein besonders lästiges Nicht-Feature-Feature sind in meinen Augen JavaBeans, wie wir sie gerade gesehen haben. Leicht verständlich, aber strikte Richtlinien durch Konvention. Und wehe, dein Framework mag die Namen Deiner Getter und Setter nicht.}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Dasselbe in Scala}
\small
	\onslide<2->
  \begin{lstlisting}
case class Person(firstName:String, lastName:String)
	\end{lstlisting}
\end{block}
\note{Ja, nur ein Beispiel, ein besonders krasses. Aber dennoch ein alltägliches.}
\end{frame}



% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{Es wird funktional -- Quicksort}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def quickSort[A <% Ordered[A]](xs: List[A]): List[A] = xs match {
  case Nil     => xs
  case y :: ys => ys partition (_ <= y) match {
    case (l1, l2) => quickSort(l1) ++ (y :: quickSort(l2)) 
	}
}
	\end{lstlisting}
\end{block}
\note{Man sieht: Ausdrucksstark, aber auch nicht mehr so straight forward wie Java (vor 8)}
\end{frame}


\begin{frame}{}
	{\usebeamercolor{normal text}\Large\textbf{Schnelldurchlauf Scala -- \alert{Endlich!}}}
	\note{Jetzt endlich ein Schnelldurchlauf durch einige grundlegende Features von Scala. Leider nur kurz, 
ich habe meine Zeit ja mit Management Summary und meiner politischen Agenda vertrödelt.
Alle Beispiele sind natürlich geklaut.

Also hier nur ein paar Dinge zum Grundverständnis und ein paar nette Sachen, die Java-Entwickler interessieren dürften.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{val und var}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val j = 3
var k = 3

j = 4
k = 4
	\end{lstlisting}
\end{block}
\onslide<3->Compile-Fehler für j, da immutable
\note{val ist Default}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Parameter sind vals}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def addOne(i: Int): Int = { i += 1; i }
	\end{lstlisting}
\end{block}
\onslide<3->Compile-Fehler, da i immutable
\note{i ist val per Default, also immutable. Letzter Ausdruck ist return}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Funktionen -- Benannte Parameter}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Schönere Methodenaufrufe}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
"Test".startsWith("T")
List(1,2,3).isEmpty
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}
"Test" startsWith "T"
List(1,2,3) isEmpty
	\end{lstlisting}
\end{block}
\note{}
\end{frame}



\begin{frame}[fragile]{}
 \begin{block}{Definition eigener Operatoren}
\scriptsize
\begin{overlayarea}{\textwidth}{4cm}
	\begin{onlyenv}<2-4>
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}

}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<5->
	\begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}
  def -(time: Time) = minus(time)
}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<3>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))

			
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<4-5>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)

	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<6->
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)
Time(10,20) - Time(1,10)
	\end{lstlisting}
	\end{onlyenv}
	\end{overlayarea}
\end{block}
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Klassen und Objekte}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Listen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Pattern Matching}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Type Inference}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f() = 3 * 2

def f() : Int = 3 * 2
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Implizites return}
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    "B"
}
	\end{lstlisting}
\end{block}
\onslide<3->{Letzte Anweisung wird zurückgegeben, impliziter Typ String.}
\note{Kein return, letzte Anweisung wird zurückgegeben.
Die Methode ist statisch typisiert! Der Compiler kann den Typen der Rückgabe ermitteln: String -- Type Inference
Wenn wir wollen, können wir ihn deklarieren. Bei öffentlichen Methoden sollte man das auch tun.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Type Inference II}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    1
}
	\end{lstlisting}
\end{block}
Erste gemeinsame Oberklasse, zur Not Any
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Vererbung und Traits}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}



\begin{frame}[fragile]{}
 \begin{block}{Funktionen funktional -- Lambdas schön}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Flatmap that shit!}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Arbeit mit Strings}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Tupel}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Implicits}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{??? -- Mein heimlicher Star}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = ???
  def -(time: Time) = minus(time)
}
	\end{lstlisting}
\end{block}
\onslide<3->{Kompilierbar, aber nicht gefährlich.}
\note{}
\end{frame}


\subsection{Spannendes}

\begin{frame}{}
	\begin{block}{Aktoren}
		\begin{itemize}
				\item<2->Nebenläufige Einheiten
				\item<3->Empfangen Nachrichten (Ereignisse)
				\item<4->Abarbeitung FIFO
				\item<5->Verhaltensänderung
				\item<6->Asynchrone Kommunikation mit Aktoren
			\end{itemize}
	\end{block}
	\note{The Actor Model, which was first proposed by Carl Hewitt in 1973 [5] and was improved, among others, by Gul Agha [6]. This model takes a different approach to concurrency, which should avoid the problems caused by threading and locking.

In the actor model, each object is an actor. This is an entity that has a mailbox and a behaviour. Messages can be exchanged between actors, which will be buffered in the mailbox. Upon receiving a message, the behaviour of the actor is executed, upon which the actor can: send a number of messages to other actors, create a number of actors and assume new behaviour for the next message to be received.

Of importance in this model is that all communications are performed asynchronously. This implies that the sender does not wait for a message to be received upon sending it, it immediately continues its execution. There are no guarantees in which order messages will be received by the recipient, but they will eventually be delivered.

A second important property is that all communications happen by means of messages: there is no shared state between actors. If an actor wishes to obtain information about the internal state of another actor, it will have to use messages to request this information. This allows actors to control access to their state, avoiding problems like the lost-update problem. Manipulation of the internal state also happens through messages.

Each actor runs concurrently with other actors: it can be seen as a small independently running process.}
	\note{Das ist ähnlich der reinen Objektorientierung, aber komplett asynchron. Die Idee ist übrigens alt (1973) und schon lange, z.B. in Erlang im Einsatz. Momentan passen die Probleme aber.
	http://www.brianstorti.com/the-actor-model/ }
\end{frame}


\begin{frame}{}
	\begin{block}{Akka}
		\begin{itemize}
			\item<2->Aktoren
			\note<2>{Klar, sonst hätte es die vorherige Folie nicht gegeben.
			Actors give you:
Simple and high-level abstractions for concurrency and parallelism.
Asynchronous, non-blocking and highly performant event-driven programming model.
Very lightweight event-driven processes (several million actors per GB of heap memory).
}
			\item<3->Fehlertoleranz
			\note<3>{
    Supervisor hierarchies with "let-it-crash" semantics.
    Supervisor hierarchies can span over multiple JVMs to provide truly fault-tolerant systems.
    Excellent for writing highly fault-tolerant systems that self-heal and never stop.
}
			\item<4->Standort-Transparenz
			\note<4>{}
			\item<5->Nachrichten-Persistenz
			\note<5>{Messages received by an actor can optionally be persisted and replayed when the actor is started or restarted. This allows actors to recover their state, even after JVM crashes or when being migrated to another node.}
			\item<6->Reaktiv laut Manifest
		\end{itemize}
	\end{block}
	\note{Was bringt uns das nun: Ziemlich viel von dem, was moderne verteilte Systeme kennen sollten.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Ping(pong: ActorRef) extends Actor {
  var count = 0
  def incrementAndPrint { count += 1; println("ping") }
	\end{lstlisting}
\end{block}
\note{http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=4]
  def receive = {
    case StartMessage =>
        incrementAndPrint
        pong ! PingMessage
    case PongMessage => 
        incrementAndPrint
        if (count > 99) {
          sender ! StopMessage
          println("ping stopped")
          context.stop(self)
        } else {
          sender ! PingMessage
        }
  }
}
	\end{lstlisting}
\end{block}
\note{http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Pong-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=19]
class Pong extends Actor {
  def receive = {
    case PingMessage =>
        println("  pong")
        sender ! PongMessage
    case StopMessage =>
        println("pong stopped")
        context.stop(self)
  }
}
	\end{lstlisting}
\end{block}
\note{Ein einfaches Beispiel, aber man sieht, wie hier Nachrichten ausgetauscht werden. Das soll hier aber keine Akka-Schulung sein, die ich auch nicht halten könnte, sondern
eine Idee geben, warum Scala geeignet sein könnte, Aktoren zu implementieren.}
\end{frame}



\begin{frame}{}
	\begin{block}{Warum in Scala}
		\begin{itemize}
			\item<2->Pattern Matching
			\item<3->Funktional
			\item<4->Weniger Code
			\item<5->Besser verständlich
		\end{itemize}
	\end{block}
	\note{Akka kann man auch mit Java umsetzen. Aber insbesondere das Pattern Matching macht einem das Leben mit Scala viel leichter. 
Es ist einfach natürlicher.}
\end{frame}




\begin{frame}{}
	 \begin{block}{Domain Specific Languages}
			 \begin{itemize}
				 \item<2->Fachliche Abstraktion
				 \item<3->Verständlicher
				 \item<4->Entwicklung schwierig
				 \item<5->Einschränkungen vorhanden
				\note<5->{Gegenüber externen DSLs wie Xtext, die beliebige Syntax erlauben}
			 \end{itemize}
	 \end{block}
	 \note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{DSL -- Beispiel}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
100 PRINT "Distance " % 'dist % "km, " % "Velocity " % 'v % "km/s, " % "Fuel " % 'fuel
110 INPUT 'burn
120 IF ABS('burn) <= 'fuel THEN 150
130 PRINT "You don't have that much fuel"
140 GOTO 100
150 LET ('v := 'v + 'burn * 10 / ('fuel + 'mass))
	\end{lstlisting}
\end{block}
\note{Ist natürlich Quatsch, zeigt aber, was geht. Und wir kommen auch gleich }
\end{frame}


\begin{frame}{}
	\begin{block}{DSL sinnvoll -- ScalaTest}
		\begin{itemize}
			\item<2->Fachlich verständliche Tests
			\item<3->Testdatengenerierung
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Scalatest -- Beispiel}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
"Creating a Time" should {
    "throw an IllegalArgumentException for hours less than 0 or greater equal 24" in {
      forAll("hours") { (hours: Int) =>
        whenever(hours < 0 || hours >= 24) {
          an[IllegalArgumentException] should be thrownBy Time(hours)
        }
      }
    }
  }
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}{Meine wenig qualifizierte Meinung}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Vorteile}
		\begin{itemize}
			\item<3->Für moderne Architekturen
			\item<4->Verständlich funktional
			\item<5->Java-Ökosystem
			\item<6->Macht Spaß
			\item<7->Statisch typisiert
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<8->
      \begin{block}{Nachteile}
		\begin{itemize}
			\item<9->Komplex
			\item<10->Zukunftssicher?
			\note<10->{Ich glaube ja, und mittlerweile ist es auch keine Nische mehr. Wenn man aber darauf angewiesen ist, dass eine Technologie auch in 10 Jahren noch genauso vorhanden ist (was wahrscheinlich schlecht ist), dann muss man vielleicht den an sich schlechteren Mainstream wählen. Scala ist aber bei weitem nicht mehr esoterisch.}
			\item<11->Anzahl Entwicklungssklaven
			\note<11->{Es gibt eine Lernkurve, man braucht Entwickler, die Spaß daran haben und die Vorteile sehen wollen.}
			\item<12->Binärkompatibilität nicht in alle Ewigkeit
			\note<12->{Ist besser geworden, insbes. mit Java 8. Die Scala-Macher sind aber nicht so konservativ wie Oracle. Aber wozu das führt, haben wir ja gesehen.}
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{}
  \begin{quote}
		{\large We’ve found that Scala has enabled us to \alert{deliver things faster} with less code. It’s reinvigorated the team.}
		\vskip3mm
		\hspace*\fill{\small--- Graham Tackley, Guardian}
	\end{quote}
	\note{Der Guardian ist der Inbegriff für den Technologiewandel in einer klassischen, behäbigen Branche. Lange, bevor Springer wach geworden ist.}
\end{frame}

\begin{frame}{}
	\begin{block}{Mehr für Nerds}
		\begin{itemize}
			\item<2->Sprecht mich an
			\item<3->Hands on-Termin bei Interesse
			\item<4->Heiko Seeberger: "`Durchstarten mit Scala. Tutorial für Einsteiger (2. Aufl.)"'
		\end{itemize}
	\end{block}
	\note{Wie gesagt habe ich wenig Ahnung von Scala, da ich es noch nicht produktiv eingesetzt habe. Ich lasse mich aber gerne zwingen, 
für Interessierte ein Hands on durchzuführen, bei dem wir ein paar Stunden mit Scala in einer echten IDE spielen, nicht auf Folien.
Ich würde natürlich auch dafür aus Büchern klauen.}
\end{frame}


% Abschlussfolie, leer und dunkel.
\plain{}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%
% Vorlagen
%%%%%%%%%%%%%%%%%%%%%%%
\appendix

% Notes
% Notes können innerhalb von Folien definiert und mit Overlays spezifiziert werden. Dann werden sie entsprechend zum Folienteil angezeigt.
% Nach der Folie definierte Notes werden der Folie zugeordnet, aber nur einmal - am Ende der Folie - ausgegeben.

% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


% Listing mit Header
\begin{frame}[fragile]{Primzahlen}
	\begin{block}{}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def swap(i: Int, j: Int) {
	val t = xs(i); xs(i) = xs(j); xs(j) = t
	()
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


% Großer Text
\begin{frame}{}
	\Large\textbf{}
	\note{}
\end{frame}


% Einfacher Block
\begin{frame}{}
	\begin{block}{}
		
	\end{block}
	\note{}
\end{frame}


% Aufzählung
\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Vergleich
\begin{frame}{}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}

