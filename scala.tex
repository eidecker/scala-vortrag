\documentclass[14pt,aspectratio=169]{beamer} %aspectratio=169 %aspectratio=43 % beamer, trans erzeugt Folien ohne Overlay
\usepackage[ngerman]{babel}
\usepackage[ansinew]{luainputenc}
\usepackage{listings}
\usepackage{pgfpages} % Second screen
\setbeameroption{hide notes} % show notes on second screen=bottom % hide notes % show notes % show only notes
\setbeamerfont{note page}{size=\tiny}


% Some colors
\definecolor{hBlue}{HTML}{004C99}
\definecolor{hBlack}{HTML}{555555}
\definecolor{hHeaderRed}{HTML}{E32119}
\definecolor{hBgLightBlue}{HTML}{E9E9E9}
\definecolor{hDarkBlue}{HTML}{00264C}

\definecolor{mDarkBrown}{HTML}{604c38}
\definecolor{mDarkTeal}{HTML}{23373b}
\definecolor{mLightBrown}{HTML}{EB811B}
\definecolor{mLightGreen}{HTML}{14B03D}

% Some styles for listings
\lstset{tabsize=2}
\lstdefinestyle{customscala}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Scala,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Java,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}

\lstset{style=customscala}

\usetheme[progressbar=foot, 
					numbering=none, 
					background=light,
					block=transparent]{metropolis} % block:fill
\setsansfont[BoldFont={Fira Sans},ItalicFont={Fira Sans Light Italic}]{Fira Sans Light}
\metroset{sectionpage=none} %sectionpage=progressbar

\setbeamercolor{normal text}{fg=hBlue, bg=black!2}
\setbeamercolor{alerted text}{fg=hHeaderRed}
\setbeamercolor{example text}{fg=mLightGreen}
\setbeamercolor{titlelike}{use=normal text, parent=normal text}
\setbeamercolor{author}{use=normal text, parent=normal text}
\setbeamercolor{date}{use=normal text, parent=normal text}
\setbeamercolor{institute}{use=normal text, parent=normal text}
\setbeamercolor{structure}{use=normal text, fg=normal text.fg}
\setbeamercolor{palette primary}{use=normal text, fg=normal text.bg, bg=normal text.fg}
\setbeamercolor{frametitle}{use=palette primary, parent=palette primary}
\setbeamercolor{progress bar}{use=alerted text, fg=alerted text.fg, bg=alerted text.fg!50!black!30}
\setbeamercolor{title separator}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in head/foot}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in section page}{use=progress bar, parent=progress bar}
%block transparent
\setbeamercolor{block title}{use=normal text, fg=hBlack, bg=}
\setbeamercolor{block body}{bg= }
\setbeamercolor{block body alerted}{use=block body, parent=block body}
\setbeamercolor{block body example}{use=block body, parent=block body}
\setbeamercolor{footnote}{fg=normal text.fg!90}
\setbeamercolor{footnote mark}{fg=.}

%% End color definition

% Subsectionpage
\AtBeginSubsection{\frame{\subsectionpage}}

\defbeamertemplate{subsection page}{progressbar}{
  \centering
  \begin{minipage}{22em}
    \raggedright
    \usebeamercolor[fg]{section title}
    \usebeamerfont{section title}
    \insertsectionhead\\[-1ex]
    \usebeamertemplate*{progress bar in section page}
    \par
    \ifx\insertsubsection\@empty\else%
      \usebeamercolor[fg]{subsection title}%
      \usebeamerfont{subsection title}%
      \insertsubsection
    \fi
  \end{minipage}
  \par
  \vspace{\baselineskip}
}

\setbeamertemplate{subsection page}[progressbar]
% End Subsectionpage

\usepackage{appendixnumberbeamer}
\usepackage[scale=2]{ccicons}
\usepackage{xspace}

\title{Scala (Programmiersprache)}
\subtitle{Sicht eines Java-Entwicklers sowie \\Gedanken zum Wandel in der IT}
\date{4. Mai 2016}
\author{Sebastian Eidecker}

\begin{document}

\maketitle




\begin{frame}{}
  \begin{quote}
		{\large\textbf{Wer als Werkzeug nur einen Hammer hat,\\sieht in jedem Problem einen Nagel.}}
		\vskip3mm
		\hspace*\fill{\small--- Paul Watzlawick}
	\end{quote}
	\note{
Ich möchte heute über Scala reden. Eigentlich will ich aber nicht nur über Scala reden.  Ich möchte nicht Scala verkaufen, sondern etwas völlig anderes. Scala ist spannend - für Nerds, die des Geldes wegen Java benutzen, denen aber mittlerweile Oracles Update-Politik nicht mehr gefällt. 
	
In der IT wollen wir Probleme lösen und Möglichkeiten schaffen.
Ich bin der festen Überzeugung, dass wir zu selten über den Kern unserer Probleme nachdenken und auch, dass sich diese Probleme gerade ändern und immer schneller ändern werden.

Ich glaube daher, dass wir unser Problem \alert{und} unseren Werkzeugkasten kennen müssen. Ich glaube, dass wir zumindest wissen müssen, was im Baumarkt ausliegt und wir bei Bedarf einkaufen können. Daher kann es aus meiner Sicht nie schaden, sich neue Werkzeuge und Arbeitsweisen anzuschauen, damit man sie bei Bedarf zumindest im Hinterkopf hat. Sonst kann es passieren, dass wir das Problem gar nicht verstehen, weil wir kein passendes Werkzeug dafür besitzen und verwenden können.

}
\end{frame}


\begin{frame}<presentation:0>{}
	\begin{block}{Über mich}
		\begin{itemize}
			\item<2->Softwareentwickler
			\item<3->Enterprise-geschädigt
			\item<4->Java-geprägt
		\end{itemize}
	\end{block}
	\note{Erzählen, wer ich bin, was ich mache und warum das meine Sicht auf die IT-Welt und Scala massiv beeinflusst}
\end{frame}

\begin{frame}{}
	\setbeamertemplate{section in toc}[sections unnumbered]
	\begin{block}{Worüber will ich reden?}
		\vskip2mm
		\onslide<1->{\tableofcontents[pausesections,pausesubsections,subsubsectionstyle=hide]} %[hideallsubsections]}
	\end{block}
	\note{Ich will nicht nur über Scala reden. Da ich netterweise als erster Redner einer neuen Veranstaltung eingeladen wurde, möchte ich mir die Freiheit nehmen, etwas grundsätzlicher über die Softwareentwicklung zu reden.
	
	Ich glaube, dass sich gerade -- oder auch schon seit einigen Jahren -- etwas Grundlegendes verändert. Die IT bekommt eine neue Rolle und auch viel mehr Bedeutung und Verantwortung. Diese Zukunft müssen wir gestalten. In Unternehmen. Als Unternehmen.
	
	}
\end{frame}


\section[IT im Wandel]{IT im Wandel -- Mal wieder}

\subsection{Ein neuer Anspruch}

\begin{frame}{}
	\only<1>{\Large\textbf{Software Engineering}}\only<2>{\Large\textbf{Software \alert{Engineering}}}
	\note{Software Engineering. Passt der Begriff? Ich denke, dies impliziert zu stark, dass wir ein Problem nur lange genug durchdenken, exakt definieren und dann eine gute Lösung bauen müssen. Womöglich verstehe ich den Beruf des Ingenieurs falsch, aber ich glaube, wir haben gesehen, dass Software agil gebaut werden sollte, dass wir nicht zu Beginn eines Projektes alle Anforderungen exakt spezifizieren können. Und: Wir können kein System bauen, das hunderte Jahre stabil steht, wie eine Kirche oder Brücke. Wir müssen es ständig pflegen und verbessern, damit es nützlich bleibt.
	
}
\end{frame}

\begin{frame}{}
	\begin{block}{Agiles Manifest (2001)}
		% Todo: Ausführlicher, die Punkte sind wichter als...
		\begin{itemize}
			\item<2->Individuen und Interaktionen mehr als Prozesse und Werkzeuge
			\item<3->Funktionierende Software mehr als umfassende Dokumentation
			\item<4->Zusammenarbeit mit dem Kunden mehr als Vertragsverhandlung
			\item<5->Reagieren auf Veränderung mehr als das Befolgen eines Plans
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{}
	\begin{block}{Software Craftsmanship (2009)}
		\begin{itemize}
			\item<2->Gut gefertigte Software
			\item<3->Stets Mehrwert schaffen
			\item<4->Gemeinschaft aus Experten bilden
			\item<5->Produktive Partnerschaften mit Kunden
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{}
	\begin{block}{Reaktives Manifest (2013)}
		\begin{itemize}
			\item<2->Antwortbereit
			\item<3->Widerstandsfähig
			\item<4->Elastisch
			\item<5->Nachrichtenorientiert
		\end{itemize}
	\end{block}
\end{frame}


\note{Es gibt Manifeste von Softwareentwicklern, die sehr Ähnliches aussagen. (Reaktives Manifest, agiles Manifest, Manifest der Software Craftmanship-Bewegung als Beispiele) Diese sind bekannt und -- ich habe zumindest das Gefühl -- auch anerkannt. Ich will auch nur sehr kurz darauf eingehen, es soll ja vor allem um Scala gehen.

Im Grunde geht es überall darum, gemeinsam Software zu entwickeln, dabei die Bedürnisse des Kunden aktiv zu erforschen und möglichst zuverlässige und nützliche Software zu erstellen.
}

\begin{frame}{}
	\only<1>{\Large\textbf{Nur Manifeste?}}
	\only<2>{\Large\textbf{Realitätsabgleich}}
	\note{Erst einmal nur Manifeste. Sie stammen jedoch von Praktikern. Also schauen wir mal in die aktuelle Welt. Ich denke nämlich, die Anforderungen und die Rolle der IT ändern sich gerade dramatisch.
	
	Ein paar Schlagworte: Was passiert eigentlich gerade?
	
	}
\end{frame}

\subsection{Eine neue Rolle}

\begin{frame}{}
	\only<1>{\Large\textbf{Mobile first}}\only<2>{\Large\textbf{Mobile first -- \alert{Only mobile?}}}	
	\only<1>{\Large\textbf{}}
	\note{
	
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Internet of Things}}
	\note{
	
	}
\end{frame}


\begin{frame}{}
	\only<1>{\Large\textbf{Rasante Releasezyklen -- DevOps}}
	\note{Ein kompletter Umbau der bisherigen Release- und Betriebsvorstellungen.
	
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Industrie 4.0}}
	\note{
	
	}
\end{frame}


\begin{frame}{}
	\only<1>{\Large\textbf{Vier-Sektoren-Hypothese}}
	\note{
	
	}
\end{frame}

\begin{frame}[plain]
\begin{block}{Sektorenmodell nach Colin Clark}
   \begin{centering} 
     \pgfimage[height=0.85\paperheight]{Clarks_Sector_Model.png} 
     \par
   \end{centering}
	\end{block}
	\note{https://en.wikipedia.org/wiki/Colin_Clark_%28economist%29
	
	}
\end{frame} 

\begin{frame}{}
  \begin{quote}
		{\Large\textbf{Software is eating the world}}
		\vskip3mm
		\hspace*\fill{\small--- Marc Andreesen, 2011}
	\end{quote}
	\note{Bei Marc Andreesen gipfelt es in dem Satz ...
% Todo: Genaue Bedeutung: http://genius.com/Marc-andreessen-why-software-is-eating-the-world-annotated
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Google, Amazon, Uber, Facebook}}
	\only<2>{\Large\textbf{Wer baut in 30 Jahren Autos?}}
	\only<3>{\Large\textbf{Mit welchem Geschäftsmodell?}}
	\note{Vielleicht: Uber lässt von Google Autos bauen, nutzt deren Karten und bietet selbst fahrende Taxis?
	
	Ich habe die Autos als Beispiel verwendet, weil sie bei uns Deutschen so tief verwurzelt sind. Als ich Jugendlicher war, wollte/musste fast jeder einen Führerschein haben. Die Automobilindustrie ist mächtig. Das nicht vorhandene Tempolimit auf Autobahnen ist uns heilig. Für andere Branchen gilt sicher Ähnliches.
	
	}
\end{frame}




% Todo: Raus, da Hellmann-Interna? Stattdessen öffentliche Quelle suchen
\begin{frame}{}
	\begin{block}{Konkrete Forderungen des Business}
		\begin{itemize}
			\item<2->Stabilität und Resilienz
			\note<2>{Sorgen sie durch ihre Arbeit dafür, dass Systeme Kriterien der Stabilität und Resilienz erfüllen.
			Seien sie "`dran"' an den Problemen, antizipieren sie sie, schaffen sie Fall-Back-Lösungen -- auch an Wochenenden.
			
			}
			\item<3->Wertbeitrag
			\note<3>{IT entwickelt sich zunehmend zu einem eigenen Produktionsfaktor (4-Sektor-Hypothese).
			Seien sie ein verlässlicher Partner für das Business, nehmen sie die Business-Seite auch an die Hand, helfen und unterstützen sie, leisten sie einen wahrgenommenen Wertbeitrag.[...]
			
			}
			\item<4->Businesstreiber
			\note<4>{Die Entwicklung der IT treibt zunehmend die Business-Seite und verändert Geschäftsmodelle.
			Seien sie an der Front und treiben sie das Business, entwickeln sie neue Ideen, forschen sie nach neuen Lösungen (Beispiele: Uber, 3D-Printing, CoLo21, ...
			
			}
		\end{itemize}
		\onslide<5->{\vskip3mm --- Manager eines Logistik-Unternehmens}
		\note<5->{Das Bewusstsein, dass ein Wandel stattfindet, ist im Business angekommen!}
	\end{block}
\end{frame}


\begin{frame}{}
	\only<1>{\Large\textbf{Unsere Projekte}}\only<2>{\Large\textbf{Unsere Projekte -- \alert{Wo stehen wir?}}}
	\note{Passt das? Haben wir ähnliche Herausforderungen? Haben wir diese schon gelöst?
	
	}
\end{frame}


\section{Scala}

\subsection{Management Summary}

\begin{frame}{}
	\Large\textbf{\alert{Sca}}lable \textbf{\alert{La}}nguage
	\only<2->{
	\vskip3mm
	\begin{quote}
		{\normalsize This means that Scala grows with you. You can play with it by typing \alert{one-line expressions} and observing the results. But you can also rely on it for \alert{large mission critical systems} [...]}
		\vskip3mm
		\hspace*\fill{\small--- www.scala-lang.org}
	\end{quote}
	}
	\note{Was bedeutet das? Scala ist sehr flexibel. Es vereint sehr viele Konzepte und ist im API-Design sehr stark. So sollen unterschiedlichste Szenarien und Anforderungen bedient werden. Schauen wir, ob das Versprechen gehalten wird.
	
	}
\end{frame}


\begin{frame}{}
	\begin{block}{Eigenschaften}
		\begin{itemize}
			\item<2->Objektorientiert -- Alles ist ein Typ
			\note<2>{Keine Primitive, wie in Java. Ein schönes Beispiel: Dort hat man per Autoboxing Komplexität eingeführt statt Schönheit. NullPointer bei Primitiven anyone?}
			\item<3->Funktional -- First class functions
			\item<4->Statisch typisiert mit Type Inference
			\note<4>{Aber Type Inference, wenn gewünscht}
			\item<5->Immutable wird bevorzugt
			\item<6->Gewohnte Syntax ("`Java ohne Semikolon"')
			\item<7->Ausdrucksstark (APIs/DSLs)
			\note<7>{Bei Java bricht man sich schon die Hände, will man ein Builder-Pattern rekursiv umsetzen oder eine fluent API}
			\item<8->Jung (2004, Hype 2011)
		\end{itemize}
	\end{block}
\end{frame}
\note{}

\begin{frame}{}
	\begin{block}{Versprechen}
	\begin{itemize}
		\item<2->Produktivitätssteigerung
		\item<3->Höhere Codequalität
		\item<4->Mehr Spaß
		\note<4>{REPL, habe ich mir für Java schon immer gewünscht. Wer hat keine Testklasse, um mal etwas auszuprobieren?}
		\item[]<5->\alert{durch}
		\item<5->Weniger Code
		\item<6->Höheres Abstraktionsniveau
		\item<7->Skalierbarkeit
	\end{itemize}
	\end{block}
\end{frame}
\note{Passt in unseren Entwicklungsprozess. Leichte Änderungen an Deployment etc.

}


\subsection{Entwicklungsumgebung}
\note{Wie sieht die Entwicklung mit Scala aus}

\begin{frame}{}
	\begin{block}{Scala und die Java-Plattform}
		\begin{itemize}
			\item<2->Java-Bytecode, läuft auf JVM
			\item<3->Java-Bibliotheken nutzbar
			\item<4->Ähnliches Toolset, oft wiederverwendbar
			\note<4,5>{Wenn man schon eine neue Sprache lernt, wird man wenigstens bei IDE und Buildprozess abgeholt.}
			\item<5->Projektstruktur wie Maven
			\item<6->Erfindet das Rad nicht sinnlos neu
			\note<6>{Neue Bibliotheken und Konzepte, wo Probleme erkannt werden, es wird nicht alles neu geschrieben und neu konzeptioniert. Gedanklich, auch was Architekturprinzipien angeht, nah an Java.}
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\begin{frame}{}
	\begin{block}{IDE-Unterstützung}
		\begin{itemize}
			\item<2->Die üblichen Verdächtigen 
			\item<3->Ausgewachsene IDEs: IntelliJ, Eclipse, Netbeans
			\item<4->Plugins für Editoren: Emacs, vi, ...
			\item<5->Mittlerweile sehr ordentlich
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Todo
\begin{frame}{}
	\begin{block}{SBT -- Scala build tool}
		\begin{itemize}
			\item<2->Buildtool für Scala-Projekte
			\item<3->Unterstützt Java-Code
			\item<4->Unterstützt interaktiven Read eval print loop-Modus
			\item<5->Inkrementelles Kompilieren -- scalac ist langsam
			\item<6->Konfiguration per Scala-DSL
			\item<7->Tasks sind Scala-Funktionen
			\item<8->\texttt{scalac} und \texttt{scala} funktionieren auch
		\end{itemize}
	\end{block}
	\note{Typische Befehle clean compile run package test}
\end{frame}

\subsubsection*{PRÄSENTATION - REPL}
% REPL-Demo in Kommandozeile
\note{REPL-Demo und Scratchpad IntelliJ}
\plain{REPL}


% Todo
\begin{frame}[fragile]{}
	\begin{block}{SBT-Buildfile}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
organization := "org.eidecker"
name := "demo-scala-vortrag"
version := "1.0"

scalaVersion := "2.11.8"
scalacOptions ++= List(
  "-unchecked", "-deprecation",
  "-target:jvm-1.8", "-encoding", "UTF-8"
)

libraryDependencies ++= List(
  "org.scalacheck" %% "scalacheck" % "1.12.5" % "test",
  "org.scalatest"  %% "scalatest"  % "2.2.5"  % "test"
)
	\end{lstlisting}
	\end{block}
	\note{Definiert die grundlegende Konfiguration unseres Projektes, mit deren Hilfe SBT das Projekt bauen kann
	
	libraryDependencies += groupID % artifactID % revision % configuration
	Resolver bestimmt, woher die Libs geholt werden. 
	
	Predefined: u.A. Maven (http://www.scala-sbt.org/0.13/docs/Resolvers.html)
	}
\end{frame}

% Todo
\begin{frame}{}
	\begin{block}{Continuous Integration}
		\begin{itemize}
			\item<2->SBT-Plugins für Jenkins/Bamboo
			\item<3->Unit-Tests: Scalatest
			\item<4->Statische Codeanalyse: ScalaStyle
			\item<5->Tools für die JVM funktionieren
		\end{itemize}
	\end{block}
	\note{Also alles wie gewohnt
	
	}
\end{frame}


\subsection{Code}
\note{Vieles geklaut von Wikipedia oder Heiko Seebergers Buch}

\begin{frame}{}
	\begin{block}{Scala in Code-Beispielen}
		\begin{itemize}
			\item<2->Ausgewählte Bereiche -- Scala ist komplex
			\item<3->Von einem Java-Entwickler ausgesucht
			\note<3>{Die Auswahl ist daher subjektiv, insbesondere funktionale Aspekte kommen sehr kurz.}
			\item<4->Kein Scala-Kurs
			\item<5->Ziel: Charakter der Sprache zeigen
		\end{itemize}
	\end{block}
	\note{Komplexität erinnert mich an die deutsche Grammatik. Man beherrscht sie irgendwann recht gut. Soll man aber grammatikalische Figuren angeben, ist man schnell am Ende. Außer man lernt die Details.
	
	}
\end{frame}

\subsubsection*{Einführendes Beispiel und Gegenbeispiel DONE}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<2->
  \begin{lstlisting}
public class Person {
	private final String firstName;
	private final String lastName;
	public Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
					}
	public String getFirstName() {
			return firstName;
	}
	public String getLastName() {
			return lastName;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=14]
	@Override
	public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Person person = (Person) o;
			if (firstName != null ? 
					!firstName.equals(person.firstName) : 
					person.firstName != null) return false;
			if (lastName != null ? 
					!lastName.equals(person.lastName) : 
					person.lastName != null) return false;
			return true;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=27]
	@Override
	public int hashCode() {
			int result = firstName != null ? firstName.hashCode() : 0;
			result = 
					31 * result + (lastName != null ? lastName.hashCode() : 0);
			return result;
	}
}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
	\Large\textbf{Businesslogik?}
	\note{Wo ist die Businesslogik versteckt? Ich gebe zu, das wird nur ein Beispiel, aber es zeigt symptomatisch eine Schwäche von Java: 
Java ist leicht verständlich, Änderungen werden aber immer non-breaking eingeführt und fühlen sich oft deplatziert an.
Scala hat den Vorteil, neuer zu sein und kennt die Schmerzen der Java-Entwickler. Daher sind viele Dinge eingebaut, die man sich schon lange wünscht 
oder Konzepte, die man eigentlich schon immer umsetzen wollte, wenn es denn nicht so lästig wäre.
(Immutable Objects, Lambdas, Generics, checked Exceptions als Beispiel)

Ein besonders lästiges Nicht-Feature-Feature sind in meinen Augen JavaBeans, wie wir sie gerade gesehen haben. Leicht verständlich, aber strikte Richtlinien durch Konvention. Und wehe, dein Framework mag die Namen Deiner Getter und Setter nicht.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Dasselbe in Scala}
\small
	\onslide<2->
  \begin{lstlisting}
case class Person(firstName:String, lastName:String)
	\end{lstlisting}
\end{block}
\note{Ja, nur ein Beispiel, ein besonders krasses. Aber dennoch ein alltägliches.}
\end{frame}



% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{Es wird funktional -- Quicksort}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def quickSort[A <% Ordered[A]](xs: List[A]): List[A] = xs match {
  case Nil     => xs
  case y :: ys => ys partition (_ <= y) match {
    case (l1, l2) => quickSort(l1) ++ (y :: quickSort(l2)) 
	}
}
	\end{lstlisting}
\end{block}
\note{Man sieht: Ausdrucksstark, aber auch nicht mehr so straight forward wie Java (vor 8). Scala ist beides: Sehr einfach und fast beliebig komplex. Und dieser Quicksort ist noch lange nicht das Ende der Möglichkeiten.

}
\end{frame}

\begin{frame}[plain]
   \begin{centering} 
     \pgfimage[height=\paperheight]{Scala-Madness.PNG} 
     \par 
   \end{centering} 
\end{frame} 

\subsubsection*{Variablen DONE}

\begin{frame}[fragile]
 \begin{block}{Variablen -- val und var}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
var j = 3
j = 4
\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
val k = 3
k = 4
\end{lstlisting}
\end{block}
\onslide<4->\textbf{Compile-Fehler für k, da immutable}
\onslide<5->
\begin{lstlisting}[firstnumber=5]
val k: Int = 3
	\end{lstlisting}
\note{val ist Default. Typen kann man auch angeben}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Methoden}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f = 3 * 2

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
def f(): Int = 3 * 2

	\end{lstlisting}
	\onslide<4->
  \begin{lstlisting}[firstnumber=3]
def f(i: Int) = 3 * i
	\end{lstlisting}
	\onslide<5->
  \begin{lstlisting}[firstnumber=4]
def f(i: Int) = {
	3 * i
}
	\end{lstlisting}
\end{block}
\note{Hier mal eine Methode. Mit = definiert. Methoden können mehr als in Java, dazu später.
Die Klammern kann man sich sparen, wenn 
Typen kann man angeben, muss es aber nicht, so lange der Compiler sie ermitteln kann. 
Bei öffentlichen Methoden sollte man es aber tun, dann hat der Nutzer auch eine reelle Chance.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Parameter sind vals}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def addOne(i: Int): Int = {
  i += 1
}
	\end{lstlisting}
\end{block}
\onslide<3->\textbf{Compile-Fehler, da i immutable}
\note{i ist val, also immutable. Immer, var nicht möglich. Letzter Ausdruck ist return}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Implizites return}
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    "B"
}
	\end{lstlisting}
\end{block}
\onslide<3->{\textbf{Letzte Anweisung wird zurückgegeben, impliziter Typ String.}}
\note{
Kein return, letzte Anweisung wird zurückgegeben. Alles hat einen Typen!
Die Methode ist statisch typisiert! Der Compiler kann den Typen der Rückgabe ermitteln: String -- Type Inference
Wenn wir wollen, können wir ihn deklarieren. Bei öffentlichen Methoden sollte man das auch tun.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Type Inference -- Any}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    1
}
	\end{lstlisting}
\end{block}
\onslide<3->
\textbf{Erste gemeinsame Oberklasse, zur Not Any}
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Unit}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def print(s: String): Unit = println(s)
	\end{lstlisting}
\end{block}
\note{Wollen wir mal wirklich nichts zurückgeben, so existiert der Typ Unit. Sinnvoll bei Methoden, die ausschließlich Seiteneffekte haben. Sollte also selten sein.

}
\end{frame}



\subsubsection*{PRÄSENTATION - Alles ist ein Typ}
% Präsentation: Alles ist ein Typ im Scratchpad. Das ist aus meiner Sicht praktisch
\plain{Worksheet}


\subsubsection*{Listen DONE}

\begin{frame}[fragile]{}
 \begin{block}{Listen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val bagContent = List(1, "a", Time(12,30), 4)
	\end{lstlisting}
\end{block}
\onslide<4->
\textbf{Immutable-Listen bevorzugen}
\note{Einfache Erstellung von Listen. Type Inference auch hier, zweite ist Liste von Any. Collections gibt es immer auch Immutable, die auch schnell sind.

}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Listenoperationen}
		\scriptsize

\onslide<2->
\begin{lstlisting}[firstnumber=1]
val l1 = List.range(1, 11, 1)
val l2 = List.range(20, 8, -2)
\end{lstlisting}

\onslide<3->
\begin{lstlisting}[firstnumber=3]
l1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
l2: List[Int] = List(20, 18, 16, 14, 12, 10)
\end{lstlisting}

\onslide<4->
\begin{lstlisting}[firstnumber=5]
l1.intersect(l2)
\end{lstlisting}

\onslide<5->
\begin{lstlisting}[firstnumber=6]
res0: List[Int] = List(10)
\end{lstlisting}

\onslide<6->
\begin{lstlisting}[firstnumber=7]
l1.reverse
\end{lstlisting}

\onslide<7->
\begin{lstlisting}[firstnumber=8]
(l1 union l2 intersect l1) == l1
\end{lstlisting}
\note<7>{
== prüft auf fachliche Gleichheit. eq die Objektreferenzen.

}

\onslide<8->
\begin{lstlisting}[firstnumber=9]
res1: Boolean = true
\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Listenoperationen}
		\scriptsize
\onslide<1->
\begin{lstlisting}[firstnumber=10]
l1 ++ l2
\end{lstlisting}
\onslide<2->
\begin{lstlisting}[firstnumber=11]
l1.head
l1.tail
\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=13]
val head :: tail = l1
\end{lstlisting}	

\onslide<4->
\begin{lstlisting}[firstnumber=14]
head: Int = 1
tail: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)
\end{lstlisting}	
\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Map}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
var colors = Map("red" -> 0xFF0000,
  "turquoise" -> 0x00FFFF,
  "black" -> 0x000000,
  "orange" -> 0xFF8040,
  "brown" -> 0x804000)
	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 6]
colors += ("white" -> 0xFFFFFF)
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 7]
colors.get("red")
\end{lstlisting}
\onslide<5->
  \begin{lstlisting}[firstnumber = 8]
colors.keys
colors.values
\end{lstlisting}
\end{block}
\note{
}
\end{frame}

\subsubsection*{Collection-Struktur DONE} 
% Todo: Struktur, Immutables
% Anwendungsbeispiele, auch Maps

\begin{frame}{}
	\begin{block}{Collection-Struktur}
		\begin{itemize}
			\item<2->Alle gängigen Datenstrukturen
			\item<3->Immutable \emph{und} Mutable-Varianten
			\item<4->Je eigene Hierarchie -- Abgeleitet von Traits
			\item<5->Tendenz zu Immutable -- Predef
			\item<6->Star-Datenstruktur: Vector
			\item<7->Immutable \emph{und} schnell
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[plain]
\begin{block}{Collection-Struktur}
   \begin{centering} 
     \pgfimage[height=0.85\paperheight]{collection-traits.png} 
     \par
   \end{centering}
	\end{block}
	\note{Seq: Wohldefinierte Reihenfolge
Map: 2-Tupel, Assoziativ
Set: Menge
	
	}
\end{frame} 

\begin{frame}[plain]
\begin{block}{Immutables}
   \begin{centering} 
     \pgfimage[height=0.85\paperheight]{collection-immutable.png} 
     \par
   \end{centering}
	\end{block}
	\note{Vektor ist Star
	
	}
\end{frame} 


\begin{frame}[plain]
\begin{block}{Mutables}
   \begin{centering} 
     \pgfimage[height=0.85\paperheight]{collection-mutable.png} 
     \par
   \end{centering}
	\end{block}
	\note{
	}
\end{frame} 


\subsubsection*{Funktionen höherer Ordnung DONE}

\begin{frame}[fragile]{}
 \begin{block}{Funktionen höherer Ordnung}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val numbersDecreasing = numbers.sortWith((x, y) => x > y)	
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusOne = numbers.map(x => x + 1)
\end{lstlisting}
\end{block}
\note{Funktionen können als Parameter übergeben werden. Auch die Funktion ist ein Objekt.
Kennt man in Java mittlerweile auch, wirkt aber aus meiner Sicht nicht so schön integriert.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Funktionen als Typen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbersPlusOne = numbers.map(x => x + 1)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val addTwo = (n: Int) => n + 2
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusTwo = numbers.map(addTwo)

\end{lstlisting}
\onslide<5->
  \begin{lstlisting}[firstnumber = 4]
val descending = (n: Int, m: Int) => n > m
\end{lstlisting}
\onslide<6->
  \begin{lstlisting}[firstnumber = 5]
val sortedNumbers = numbers.sortWith(descending)
\end{lstlisting}

\end{block}
\note{Wir können Funktionen auch wie Variablen verwenden und übergeben. Es sind first class citizens. Und das ist mächtig. Das sehen wir schon in Java 8, aber in Scala war es schon immer und wird bereits fleißig in APIs genutzt. Das macht es für Programmierer, die keinen funktionalen Background haben, leider auch nicht einfacher. Methoden sind übrigens keine Objekte (Methode per def, Funktion per val deklariert.)
Methode in Funktion umwandeln
def addOne(n: Int) = n+1
val f = addOne \_

addOne kann dennoch übergeben werden, da Compiler die Arbeit übernimmt.

}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Partition}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
case class Person(name:String, age:Int)
val people = Vector(Person("Sebastian", 37),  
		Person("Fabian", 36), Person("Nils", 5))

val (children, adults) = people partition (_.age < 18)
	\end{lstlisting}
		\onslide<3->
  \begin{lstlisting}[firstnumber=5]
children: scala.collection.immutable.Vector[Person] = Vector(Person(Nils,5))
adults: scala.collection.immutable.Vector[Person] = Vector(Person(Sebastian,37), Person(Fabian,36))
	\end{lstlisting}

	\end{block}
	\note{val people: Array[Person]
    // Partition `people` into two arrays `minors` and `adults`.
    // Use the higher-order function `(_.age < 18)` as a predicate for partitioning.
    val (minors, adults) = people partition (_.age < 18)}
\end{frame}

    

% Todo: %http://docs.scala-lang.org/tutorials/tour/anonymous-function-syntax
\begin{frame}[fragile]{}
	\begin{block}{Anonyme Funktionssyntax}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}[firstnumber=1]
val addTwo = (n: Int) => n + 2
	\end{lstlisting}
	
		\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val addTwoExpressive =
new Function1[Int, Int] {
  def apply(n: Int): Int = n + 2
}
	\end{lstlisting}
		\onslide<4->
  \begin{lstlisting}[firstnumber=6]
l1.map(addTwo)
l1.map(addTwoExpressive)
	\end{lstlisting}

	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Currying - Teilweise angewandte Funktionen}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}[firstnumber=1]
def multiply(m: Int)(n: Int): Int = m * n
	\end{lstlisting}
		\onslide<3->
  \begin{lstlisting}[firstnumber=2]
multiply (2)(3)
	\end{lstlisting}
		\onslide<4->
  \begin{lstlisting}[firstnumber=3]
val timesTwo = multiply(2) _
	\end{lstlisting}
		\onslide<5->
  \begin{lstlisting}[firstnumber=4]
timesTwo(3)
	\end{lstlisting}
	\end{block}

	\note{Sometimes it makes sense to let people apply some arguments to your function now and others later.

Heres an example of a function that lets you build multipliers of two numbers together. At one call site, youll decide which is the multiplier and at a later call site, youll choose a multiplicand.

}
\end{frame}

\subsubsection*{Klassen und Objekte DONE}

\begin{frame}[fragile]{}
 \begin{block}{Klassen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int, val minutes: Int) {
  // Primärer Konstruktor
  require(hours < 24 && hours >= 0)
  require(minutes < 60 && minutes >= 0)
	
	def this() = this(0, 0)
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=8]
val t = new Time(1, 14)
val t2 = new Time
	\end{lstlisting}
\end{block}
\note{Der Standardkonstruktor für alle Parameter ist direkt im Methodenrumpf. Hilfskonstruktoren sind möglich.
val Standard, Felder sind damit verfügbar. Var möglich, dann Setzen möglich?

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Benannte Parameter und Standardwerte}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int = 0, val minutes: Int = 0)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val t = new Time(1)
val t2 = new Time(minutes = 13)
	\end{lstlisting}
\end{block}
\note{Damit werden Argumentnamen aber auch API-Bestandteil und dürfen nicht geändert werden.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Singleton/Companion Objects}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
object Time {
	def fromMinutes(minutes: Int): Time = 
			new Time(minutes / 60, minutes % 60)
}

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val t = Time.fromMimutes(100)
	\end{lstlisting}
\end{block}
\note{Companion Objects sind Singleton Objects. Sie existieren nur ein mal. "`Ersatz"' für static, das es nicht gibt. Nützlich für Factory-Methoden.
Companion Objects (selber Name, selbes Paket, selbe Datei wie Klasse) können auf private Elemente der Klasse zugreifen.

Gilt auch für Traits.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Case classes}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Person(nachname: String, vorname: String)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val ich = Person("Eidecker", "Sebastian")
val sohn = ich.copy(vorname = "Nils")
	\end{lstlisting}
\end{block}
\note{Case classes sind JavaBeans in schön. Nehmen die üblichen Dinge ab, die sowieso die IDE macht. Ideal als DTO, man kann/sollte aber nicht von ihnen erben. Hübscher "`Konstruktor"', Copy-Konstruktor und toString

}
\end{frame}


\subsubsection*{Vererbung DONE}

\begin{frame}[fragile]{}
 \begin{block}{Vererbung und Traits}
\begin{itemize}
	\item<2->Fast wie in Java
	\item<3->Mehrfachvererbung durch Traits
	\item<4->Verwendung: Weniger strukturell, funktionaler als in Java
	\item<5->Java 8 hat nachgezogen
\end{itemize}
\end{block}
\note{Ähnlich Java in den Grundzügen. Mit Traits Mehrfachvererbung möglich und funktionalerer Ansatz. Dadurch häufig kleinere Funktionsblöcke in Traits. Java 8 bietet mit default-Methoden in Interfaces ähnliches.

}
\end{frame}


\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
abstract class Animal {
  def sayHello() = println("I am an animal")
}
	\end{lstlisting}
{
\onslide<3->
\begin{lstlisting}[firstnumber=4]
class Bird extends Animal {
  override def sayHello() = println("I am a bird")
  def fly() = println("I can fly")
  def sing() = println("I can sing")
}
\end{lstlisting}
}
{
\onslide<4->
\begin{lstlisting}[firstnumber=9]
class Cow extends Animal {
  override def sayHello() = println("I am a cow")
  def walk() = println("I can walk")
}
\end{lstlisting}
}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Was ist eine Ente?}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
class Bird extends Animal
class Fish extends Animal {
  def swim() = println("I can swim")
}
	\end{lstlisting}
{
\onslide<3->
\begin{lstlisting}[firstnumber=4]
class Duck extends [???]
\end{lstlisting}
}
{
\onslide<4->
\begin{lstlisting}[firstnumber=9]
trait Swimmer {
  val message = "I can swim"
  def swim() = println(message)
}
\end{lstlisting}
}
{
\onslide<5->
\begin{lstlisting}[firstnumber=9]
class Duck extends Bird with Swimmer {
  override def sing() = println("Quak")
}
\end{lstlisting}
}
	\end{block}
	\note{}
\end{frame}


\begin{frame}{}
	\begin{block}{Traits -- Einschränkungen}
		\begin{itemize}
			\item<2->Können Methoden definieren und implementieren
			\item<3->Können Variablen definieren
			\item<4->Können erben und hineinmixen
			\item<5->Können Companion-Objekte haben
			\item<6->Haben aber keine Konstruktor-Parameter
		\end{itemize}
	\end{block}
	\note{Auflösen von Problemen durch Linearisierung der Vererbungshierarchie. Es kann zu Problemen kommen. Kann und möchte ich in dieser kurzen Zeit aber nicht motivieren. Ist in der Realität aber wohl selten ein Problem.
	
	}
\end{frame}

\subsubsection*{RAUS: PRÄSENTATION Vererbung}
%\plain{Vererbung}

\subsubsection*{Operatorendefinition DONE}

\begin{frame}[fragile]{}
 \begin{block}{Schönere Methodenaufrufe}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
"Test".startsWith("T")
List(1,2,3).isEmpty
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}
"Test" startsWith "T"
List(1,2,3) isEmpty
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Definition eigener Operatoren}
\scriptsize
\begin{overlayarea}{\textwidth}{4cm}
	\begin{onlyenv}<2-4>
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {
		new Time(this.hour - time.hour, this.minute - time.minute)
	}
	
}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<5->
	\begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {
		new Time(this.hour - time.hour, this.minute - time.minute)
	}
  def -(time: Time) = minus(time)
}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<3>
  \begin{lstlisting}[firstnumber=7]
Time(10,20).minus(Time(1,10))

			
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<4-5>
  \begin{lstlisting}[firstnumber=7]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)

	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<6->
  \begin{lstlisting}[firstnumber=7]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)
Time(10,20) - Time(1,10)
	\end{lstlisting}
	\end{onlyenv}
	\end{overlayarea}
\end{block}
\note{}
\end{frame}




\subsubsection*{Pattern Matching DONE}




%Todo: - Patterm Matching mit _
% Verschiedene Matching-Möglichkeiten darstellen

\begin{frame}[fragile]{}
	\begin{block}{Pattern Matching -- \texttt{switch} auf Steroiden}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val number = 1
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
number match {
  case 1 => "one"
  case 2 => "two"
  case _ => "some other number"
}
	\end{lstlisting}
		\onslide<4->
  \begin{lstlisting}[firstnumber=7]
number match {
  case i if i == 1 => "one"
  case i if i == 2 => "two"
  case _ => "some other number"
}
	\end{lstlisting}
	\end{block}
	\note{Sehr mächtiges Feature. Code wirkt auf einmal sinnvoll. Java-Case auf Steroids ist noch zu schwach. Vielfältige Pattern möglich. Dabei Aufspalten von Listen möglich, siehe Quicksort.
Bekannt aus rein funktionalen Sprachen.

Wird an sehr vielen Stellen verwendet.

}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Matcher für Typen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def bigger(o: Any): Any = {
  o match {
    case i: Int if i < 0 => i - 1
    case i: Int => i + 1
    case d: Double if d < 0.0 => d - 0.1
    case d: Double => d + 0.1
    case text: String => text + "s"
  }
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=10]
bigger(3); bigger("Planet"); bigger(5.0)
	\end{lstlisting}
		\onslide<4->
  \begin{lstlisting}[firstnumber=11]
res0: Any = 4
res1: Any = Planets
res2: Any = 5.1
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Matcher für Attribute}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)
   
for (person <- List(alice, bob, charlie)) {
	person match {
		case Person("Alice", 25) => println("Hallo Alice!")
    case Person("Bob", 32) => println("Hallo Bob!")
    case Person(name, age) => println("Alter: " + alter + ", Name: " + name)
  }
}
	\end{lstlisting}
\end{block}
\note{Wir können Attribute matchen und diese sogar an Variablen binden und verwenden.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Matcher -- Funktional Länge einer Liste}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def length[A](list : List[A]) : Int = {
  list match {
    case _ :: tail => 1 + length(tail)
    case Nil => 0
  }
}
	\end{lstlisting}
\end{block}
\note{Liste wird in Head und tail geteilt per :: Dann rekursiv weiter
Da fühlt sich der Compiler-Entwickler foch schon fast abgeholt.

}
\end{frame}


\subsubsection*{For mit yield DONE}

\begin{frame}[fragile]{}
	\begin{block}{For-Ausdrücke}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val times = List(Time(12,0), Time(13,0), Time(14,0))

for {
  time <- times
  minutes = time.hour * 60
} yield minutes
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 7]
List[Int] = List(720, 780, 840)
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\begin{frame}[fragile]{}
	\begin{block}{Yield -- Generatoren}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
for {
  hours <- 0 to 23
  minutes <- 0 to 59
} yield {
  new Time(hours, minutes)
}
	\end{lstlisting}
{
\onslide<3->
\begin{lstlisting}[firstnumber=7]
Vector(Time(0,0), Time(0,1), Time(0,2), ...
\end{lstlisting}
}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Yield -- Filter}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
for {
	hours <- 0 to 23
	minutes <- 0.to(59) if minutes % 15 == 0 && hours >= 22
} yield {
	new Time(hours, minutes)
}
	\end{lstlisting}
{
\onslide<3->
\begin{lstlisting}[firstnumber=7]
Vector(Time(22,0), Time(22,15), Time(22,30), Time(22,45), ...
\end{lstlisting}
}
	\end{block}
	\note{}
\end{frame}



\subsubsection*{Rekursion (tailrec) DONE}

\begin{frame}[fragile]{}
 \begin{block}{@tailrec -- Scala denkt wirklich funktional}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def factorial(n: Int): Int = {
  if (n <= 1) 1
  else n * factorial(n - 1)
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 5]
def factorialTail(n: Int): Int = {
  @tailrec
  def factorialAcc(acc: Int, n: Int): Int = {
    if (n <= 1) acc
    else factorialAcc(n * acc, n - 1)
  }
  factorialAcc(1, n)
}
	\end{lstlisting}
\end{block}
\note{Es müssen keine Ergebnisse auf dem Stack zwischengespeichert werden. Optimierung durch den Compiler. Warnung, wenn nicht tail recursive.
Recht hardcore funktional!


In traditional recursion, the typical model is that you perform your recursive calls first, and then you take the return value of the recursive call and calculate the result. In this manner, you don't get the result of your calculation until you have returned from every recursive call.

In tail recursion, you perform your calculations first, and then you execute the recursive call, passing the results of your current step to the next recursive step. This results in the last statement being in the form of "(return (recursive-function params))" (I think that's the syntax for Lisp). Basically, the return value of any given recursive step is the same as the return value of the next recursive call.

The consequence of this is that once you are ready to perform your next recursive step, you don't need the current stack frame any more. This allows for some optimization. In fact, with an appropriately written compiler, you should never have a stack overflow snicker with a tail recursive call. Simply reuse the current stack frame for the next recursive step. I'm pretty sure Lisp does this.
http://stackoverflow.com/questions/33923/what-is-tail-recursion

https://myadventuresincoding.wordpress.com/2010/06/20/tail-recursion-in-scala-a-simple-example/

Praktisch: Man kann Funktionen verschachteln.

}
\end{frame}

\subsubsection*{Tupel DONE}

\begin{frame}[fragile]{}
 \begin{block}{Tupel}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val ichMitAlter = (Person("Eidecker", "Sebastian"), 37)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val ich = ichMitAlter._1
val alter = ichMitAlter._2

	\end{lstlisting}	
	\onslide<4->
  \begin{lstlisting}[firstnumber=4]
def personMitAlter(person: Person, alter: Int): (Person, Int) = {
	(person, alter)
}
\end{lstlisting}
\end{block}
\note{Haben wir beim Pattern Matching gesehen. Tupel können aber auch nützlich sein, wenn man mal kein neues Objekt erstellen will. Oder, wenn man Maps verwendet. Oder, wenn man Funktionen als Parameter übergibt. 

}
\end{frame}

\subsubsection*{??? DONE}

\begin{frame}[fragile]{}
 \begin{block}{??? -- Mein heimlicher Star}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {

  def minus(time: Time) = ???
	
}
	\end{lstlisting}
\end{block}
\onslide<3->{Kompilierbar, aber nicht gefährlich.}
\note{Kompiliert, beim Aufruf aber Exception. Hilfreich, wenn man test first entwickelt. Dann jammert der Compiler nicht ständig.}
\end{frame}

\subsubsection*{Arbeiten mit Strings DONE}


\begin{frame}[fragile]{}
	\begin{block}{Strings}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val hello = "Hello"
val world = "world"
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
hello + ' ' + world
hello.take(4)
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=5]
res0: String = Hell
\end{lstlisting}
\onslide<5->
\begin{lstlisting}[firstnumber=6]
val latin = """Lorem ipsum
               |dolor sit amet""".stripMargin
\end{lstlisting}


\end{block}
	
\end{frame}


\begin{frame}[fragile]{}
	\begin{block}{Strings -- Formatierung}
		\scriptsize
		\onslide<1->
\begin{lstlisting}
val name = "Sebastian"
val age = 37
val weight = 80.0
\end{lstlisting}
		\onslide<2->
\begin{lstlisting}[firstnumber=4]
println(s"Hello, $name")
println(f"$name is $age years old, and weighs $weight%.1f kilograms.")
\end{lstlisting}
	\end{block}
\note{s: Variablenersetzung
	f: Formatierung
	
	}
\end{frame}




\subsubsection*{Option DONE}

% Verwendung
\begin{frame}{}
	\begin{block}{Option}
		\begin{itemize}
			\item<2->Etwas könnte vorhanden sein -- oder nicht
			\item<3->Null vermeiden
			\item<4->Unterklassen \texttt{Some[T]} und \texttt{None}
			\item<5->Gutes Zusammenspiel mit Pattern Matching
			\item<6->Java 8: \texttt{Optional}
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Pseudocode Option}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
trait Option[T] {
  def isDefined: Boolean
  def get: T
  def getOrElse(t: T): T
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Option im Einsatz}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val numbers = Map("one" -> 1, "two" -> 2)
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val two = numbers.get("two")
	\end{lstlisting}
	\onslide<4->
  \begin{lstlisting}[firstnumber=3]
two: Option[Int] = Some(2)
	\end{lstlisting}
	\onslide<5->
  \begin{lstlisting}[firstnumber=4]
val three = numbers.get("three")
	\end{lstlisting}
	\onslide<6->
  \begin{lstlisting}[firstnumber=5]
three: Option[Int] = None
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Option im Einsatz}
		\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=6]
val result = if (three.isDefined) {
  three.get * 2
} else {
  0
}
	\end{lstlisting}
	\onslide<2->
  \begin{lstlisting}[firstnumber=11]
numbers.get("three") match {
  case Some(n) => n * 2
  case None => 0
}
	\end{lstlisting}	
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Implicits DONE}

\begin{frame}[fragile]{}
	\begin{block}{Wieso?}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val tupel = 1 -> "a"
tupel: (Int, String) = (1,a)
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
"org.scalatest"  %% "scalatest"  % "2.2.5"  % "test"
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=4]
class TimeSpec extends WordSpec with Matchers with {
  "fromMinutes" should {
    "return Time(0, 10) for 10 minutes" in {
\end{lstlisting}
	\end{block}
	\note{Auf Int ist -> nicht definiert. Auf String \% und \%\% nicht, auch nicht should. Wieso also geht dies?}
\end{frame}

\begin{frame}{}
	\begin{block}{Implicits}
		\begin{itemize}
			\item<2->Sehr mächtiges Sprachfeature
			\item<3->Dinge tun, die nicht definiert sind
			\item<4->Wenn man nicht mehr versteht, was passiert
			\item<5->Das Mittel, Scala an eigene Bedürfnisse anzupassen
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}{}
  \begin{quote}
		{\large\textbf{Aus großer Kraft folgt große Verantwortung}}
		\vskip3mm
		\hspace*\fill{\small--- Ben Parker, Spiderman}
	\end{quote}
	\note{
}
\end{frame}

\begin{frame}{}
	\begin{block}{Implicits -- Formen}
		\begin{itemize}
			\item<2->Implicit Conversion zum Expected Type
			\item<3->Implicit Conversion des Receivers
			\item<4->Implicit Classes
			\item<5->Implicit Parameters
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Implicit Conversion zum Expected Type}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val n: Int = "1"
val o: Int = "Big"
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
implicit def numberToString(n: String) : Int = {
  n match {
    case "1" => 1
    case _ => 99
  }
}
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=9]
n: Int = 1
o: Int = 99
\end{lstlisting}
	\end{block}
	\note{When the compiler finds an expression of the wrong type for the context, it will look for an implicit Function value of a type that will allow it to typecheck. So if an A is required and it finds a B, it will look for an implicit value of type B => A in scope (it also checks some other places like in the B and A companion objects, if they exist).
	
	}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Implicit Conversion des Receivers}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
"09:00" - "03:00"
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=2]
val timePattern = """(\d\d):(\d\d)""".r
implicit def apply(s: String): Time =
	try {
		val timePattern(hours, minutes) = s
		Time(hours.toInt, minutes.toInt)
	} catch {
		case _: MatchError => throw new IllegalArgumentException(s"Time must have format hh:mm!")
	}
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=10]
res0: Int = 360
\end{lstlisting}
\normalsize{\textbf{Erweitert API bestehender Klassen!}}
	\end{block}
	\note{Receiver: Objekte, auf denen Methoden aufgerufen werden. Hier gibt es die Methode nicht. Der Compiler sucht nach - in String. Wir müssen ihm eine Conversion geben, so dass er Time sieht, und damit - aufrufen kann.
	
	Mächtig. Für DSLs. Sieht man aber kaum noch!}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Implicit Classes}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
6::15
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=2]
class IntOps(val n: Int) {
  def ::(hours: Int): Time = Time(hours, n)
}

implicit def intToIntOps(n: Int): IntOps = new IntOps(n)
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=7]
implicit class IntOps(val n: Int) {
  def ::(hours: Int): Time = Time(hours, n)
}
\end{lstlisting}
\onslide<5->
\begin{lstlisting}[firstnumber=10]
6::15
res1: Time = 06:15
\end{lstlisting}
	\end{block}
	\note{Kombination aus impliziter Methode und Wrapper-Klasse. Seit Scala 2.10
	
	}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Implicit Parameters}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def addOne(implicit i: Int) = i + 1
	\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=5]
implicit val defaultNumber = 0
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=5]
val one = addOne
\end{lstlisting}
\onslide<4->
\begin{lstlisting}[firstnumber=5]
one: Int = 1
\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Implicits -- Geht alles?}
		\begin{itemize}
			\item<2->Nein, es gibt klare Regeln
			\item<3->Passende Definitionen per \texttt{implicit} im Scope
			\item<4->Klare Hierarchie bei mehrdeutigen Definitionen
			\item<5->Dennoch: Bitte umsichtig verwenden!
		\end{itemize}
	\end{block}
	\note{http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html
	
	Scope: Direkt im Block, per Import, CompanionObject}
\end{frame}




% http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ab hier Streichkandidaten
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Langweiligeres ab hier DONE}


\subsubsection*{Verschachtelte Funktionen DONE}
\begin{frame}[fragile]{}
	\begin{block}{Verschachtelte Funktionen}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def factorial(n: Int): Int = {

  def factorialAcc(acc: Int, n: Int): Int = {
    if (n <= 1) acc
    else factorialAcc(n * acc, n - 1)
  }
	
  factorialAcc(1, n)
}
	\end{lstlisting}
	\end{block}
	\note{Praktisch bspw. für rekursive Funktionen. Haben wir dort schon gesehen.}
\end{frame}

\subsubsection*{Exception Handling DONE}

\begin{frame}{}
	\begin{block}{Exceptions}
		\begin{itemize}
			\item<2->Wie in Java
			\item<3->Pattern Matching
			\item<4->Selten: Option oder Either nutzen
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Exceptions}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
try {
  val f = new FileReader("input.txt")
} catch {
  case ex: FileNotFoundException => {
    println("Missing file exception")
  }
  case ex: IOException => {
    println("IO Exception")
  }
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}



\subsubsection*{Predef DONE}

\begin{frame}{}
	 \begin{block}{Predef}
			 \begin{itemize}
				 \item<2->\texttt{java.lang} für Scala
				 \item<3->Vordefinierte Objekte ohne Import sichtbar
				 \item<4->Aliasse zur Bequemlichkeit
				 \item<5->Hilfsmethoden wie \texttt{require}
				 \item<6->Tendenz zu Immutables hier manifestiert
			 \end{itemize}
	 \end{block}
	 \note{}
\end{frame}

\subsubsection*{Und viel, viel mehr DONE}
\begin{frame}{}
	\Large\textbf{Und noch viel, viel mehr ...}
	\note{Insbesondere im Bereich der funktionalen Programmierung. Aber dafür haben wir leider keine Zeit. Und ich kenne auch bwi weitem nicht alles.
	Nein, Monaden gibt es heute sicher nicht.
	
	}
\end{frame}


\subsection{Aus dem Ökosystem}

\subsubsection*{Domain Specific Languages}

\begin{frame}{}
	 \begin{block}{Domain Specific Languages}
			 \begin{itemize}
				 \item<2->Fachliche Abstraktion
				 \item<3->Verständlicher
				 \item<4->Entwicklung schwierig
				 \item<5->Einschränkungen vorhanden
				\note<5->{Gegenüber externen DSLs wie Xtext, die beliebige Syntax erlauben}
				\item<6->Häufig in Standard-Frameworks verwendet
			 \end{itemize}
	 \end{block}
	 \note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{DSL -- Beispiel}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
100 PRINT "Distance " % 'dist % "km, " % "Velocity " % 'v % "km/s, " % "Fuel " % 'fuel
110 INPUT 'burn
120 IF ABS('burn) <= 'fuel THEN 150
130 PRINT "You don't have that much fuel"
140 GOTO 100
150 LET ('v := 'v + 'burn * 10 / ('fuel + 'mass))
	\end{lstlisting}
\end{block}
\note{Ist natürlich Quatsch, zeigt aber, was geht. Und wir kommen auch gleich }
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Scalatest}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
"Creating a Time" should {
    "throw an IllegalArgumentException for hours less than 0 or greater equal 24" in {
      forAll("hours") { (hours: Int) =>
        whenever(hours < 0 || hours >= 24) {
          an[IllegalArgumentException] should be thrownBy Time(hours)
        }
      }
    }
  }
	\end{lstlisting}
\end{block}
\note{DSLs sind sinnvoll, wenn sie besser zum Ausdruck bringen, was in der Domäne beschrieben wird.

}
\end{frame}

\subsubsection*{Aktoren und Akka}

\begin{frame}{}
	\begin{block}{Aktoren}
		\begin{itemize}
				\item<2->Nebenläufige Einheiten
				\item<3->Empfangen Nachrichten (Ereignisse)
				\item<4->Abarbeitung FIFO
				\item<5->Verhaltensänderung
				\item<6->Asynchrone Kommunikation mit Aktoren
			\end{itemize}
	\end{block}
	\note{Kommen wir zu etwas wirklich Spannenden. Ich habe davon zugegeben kaum Ahnung, finde es aber so interessant, dass ich es heute erzählen muss!
	
	The Actor Model, which was first proposed by Carl Hewitt in 1973 [5] and was improved, among others, by Gul Agha [6]. This model takes a different approach to concurrency, which should avoid the problems caused by threading and locking.

In the actor model, each object is an actor. This is an entity that has a mailbox and a behaviour. Messages can be exchanged between actors, which will be buffered in the mailbox. Upon receiving a message, the behaviour of the actor is executed, upon which the actor can: send a number of messages to other actors, create a number of actors and assume new behaviour for the next message to be received.

Of importance in this model is that all communications are performed asynchronously. This implies that the sender does not wait for a message to be received upon sending it, it immediately continues its execution. There are no guarantees in which order messages will be received by the recipient, but they will eventually be delivered.

A second important property is that all communications happen by means of messages: there is no shared state between actors. If an actor wishes to obtain information about the internal state of another actor, it will have to use messages to request this information. This allows actors to control access to their state, avoiding problems like the lost-update problem. Manipulation of the internal state also happens through messages.

Each actor runs concurrently with other actors: it can be seen as a small independently running process.

Das ist ähnlich der reinen Objektorientierung, aber komplett asynchron. Die Idee ist übrigens alt (1973) und schon lange, z.B. in Erlang im Einsatz. Momentan passen die Probleme aber.
	http://www.brianstorti.com/the-actor-model/
	
	
}
\end{frame}


\begin{frame}{}
	\begin{block}{Akka}
		\begin{itemize}
			\item<2->Aktoren
			\note<2>{Klar, sonst hätte es die vorherige Folie nicht gegeben.
			Actors give you:
Simple and high-level abstractions for concurrency and parallelism.
Asynchronous, non-blocking and highly performant event-driven programming model.
Very lightweight event-driven processes (several million actors per GB of heap memory).

}
			\item<3->Fehlertoleranz
			\note<3>{
    Supervisor hierarchies with "let-it-crash" semantics.
    Supervisor hierarchies can span over multiple JVMs to provide truly fault-tolerant systems.
    Excellent for writing highly fault-tolerant systems that self-heal and never stop.

}
			\item<4->Standort-Transparenz
			\note<4>{Everything in Akka is designed to work in a distributed environment: all interactions of actors use pure message passing and everything is asynchronous.}
			\item<5->Nachrichten-Persistenz
			\note<5>{Messages received by an actor can optionally be persisted and replayed when the actor is started or restarted. This allows actors to recover their state, even after JVM crashes or when being migrated to another node.
			
			}
			\item<6->Reaktiv laut Manifest
		\end{itemize}
	\end{block}
	\note{Was bringt uns das nun: Ziemlich viel von dem, was moderne verteilte Systeme leisten sollten.
	
	}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case object PingMessage
case object PongMessage
case object StartMessage
case object StopMessage

class Ping(pong: ActorRef) extends Actor {
  var count = 0
  def incrementAndPrint { count += 1; println("ping") }
	\end{lstlisting}
\end{block}
\note{http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example
Nachrichten mit Case-Klassen, einfacher geht es nicht. Und typsicher, was mir persönlich gut gefällt.
Ein Aktor hat einen Zustand und vor allem eine receive-Methode.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=9]
  def receive = {
    case StartMessage =>
        incrementAndPrint
        pong ! PingMessage
    case PongMessage => 
        incrementAndPrint
        if (count > 99) {
          sender ! StopMessage
          println("ping stopped")
          context.stop(self)
        } else {
          sender ! PingMessage
        }
  }
}
	\end{lstlisting}
\end{block}
\note{In der receive-Methode wird das Verhalten implementiert.
http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Pong-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=19]
class Pong extends Actor {
  def receive = {
    case PingMessage =>
        println("  pong")
        sender ! PongMessage
    case StopMessage =>
        println("pong stopped")
        context.stop(self)
  }
}
	\end{lstlisting}
\end{block}
\note{Und hier das Gegenstück:
Ein einfaches Beispiel, aber man sieht, wie hier Nachrichten ausgetauscht werden. Das soll hier aber keine Akka-Schulung sein, die ich auch nicht halten könnte, sondern
eine Idee geben, warum Scala geeignet sein könnte, Aktoren zu implementieren.

Aktoren, die Daten empfangen, evtl. Zustand halten, die Daten verarbeiten und Nachrichten weiterschicken.
Das ganze hochparallelisiert, die Nachrichten werden sicher gespeichert.
Ich kann mir nicht helfen, aber das liest sich für mich wie ein Business-Prozess. Den man beliebig zusammenstecken kann. Und er funktioniert dennoch, weil man in der Programmiersprache dasselbe macht wie in einem EPK oder BPMN-Modell. (Disclaimer: Ich habe es noch nicht viel weiter als bis zu diesem Niveau ausprobiert, aber Menschen, die es getan haben, stimmen darin überein).

Und mit Scala (vor allem Pattern Matching) bricht man sich bei der Implementierung auch nicht die Finger.

}
\end{frame}



% Todo
\begin{frame}{}
	\begin{block}{Einsatzmöglichkeiten}
		\begin{itemize}
			\item<2->Live-Domänenmodell, automatisch berechnend
			\note<2>{Logik in Aktoren, berechnen sich immer live. Eventual consistent}
			\item<3->Simulation
			\item<4->Kommunikation (Messaging)
			\item<5->Batch processing
			\item<6->Workflow
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Warum in Scala?}
		\begin{itemize}
			\item<2->Pattern Matching
			\item<3->Funktional
			\item<4->Weniger Code
			\item<5->Besser verständlich
		\end{itemize}
	\end{block}
	\note{Akka kann man auch mit Java umsetzen. Aber insbesondere das Pattern Matching macht einem das Leben mit Scala viel leichter. 
Es ist einfach natürlicher.

}
\end{frame}

\subsubsection*{Akka HTTP DONE}

% Großer Text
% https://dzone.com/articles/building-rest-service-scala
\begin{frame}{}
	\Large\textbf{Akka HTTP}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Akka HTTP}
		\begin{itemize}
			\item<+->HTTP-Stack aufbauend auf Akka
			\item<+->Asynchron, non-blocking (Reactive Streams)
			\item<+->Client und Server, high-level und low-level APIs
			\item<+->Kein Framework
			\item<+->Routing-DSL
		\end{itemize}
	\end{block}
	\note{http://www.reactive-streams.org/
	
	Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.
	
	Verspricht damit, performant und elastisch zu sein. Wer also nicht in das Node-Lager wechseln will, kann bei Akka bleiben.
	
	https://medium.com/@kvnwbbr/a-journey-into-reactive-streams-5ee2a9cd7e29\#.chzpkx3iw}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Routing-DSL}
\scriptsize
\begin{overlayarea}{\textwidth}{7cm}
	\begin{onlyenv}<2>
  \begin{lstlisting}
val route =
      get {
        
				
				
				
				
				
				
				
				
				
				
          
      }
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<3>
	\begin{lstlisting}
val route =
      get {
        pathSingleSlash {
          complete("<html><body>Hello world!</body></html>")
        } 
				
				
				
				
				
				
				
				
				
      }
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<4>
  \begin{lstlisting}
val route =
      get {
        pathSingleSlash {
          complete("<html><body>Hello world!</body></html>")
        } ~
          path("ping") {
            complete("PONG!")
          } ~
          path("pong") {
            complete("PING!")
          }
					
					
					
      }
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<5>
  \begin{lstlisting}
val route =
      get {
        pathSingleSlash {
          complete("<html><body>Hello world!</body></html>")
        } ~
          path("ping") {
            complete("PONG!")
          } ~
          path("pong") {
            complete("PING!")
          } ~
          pathPrefix("echo" / Segment) { message =>
            complete(message)
          }
      }
	\end{lstlisting}
	\end{onlyenv}
	\end{overlayarea}
\end{block}
\note{Routen können auch in separaten Dateien (am besten in Traits) definiert und dann kombiniert werden.

http://qiita.com/visualskyrim/items/e3738ab93e9ca11ea7fd
}
\end{frame}



\subsubsection*{PRÄSENTATION Akka HTTP}
\plain{Akka HTTP}
\note{Es bringt nicht viel, weil es kein relevanter UseCase ist, aber dennoch will ich kurz das HelloWorld zeigen. Nicht ganz so kurz wie Node, aber immerhin.

}


\subsection*{Abschließende Worte}

\begin{frame}{Scala -- Meine Meinung}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Vorteile}
		\begin{itemize}
			\item<3->Moderne Architekturen
			\item<4->Bessere Abstraktion
			\item<5->Verständlich funktional
			\item<6->Java-Ökosystem
			\item<7->Macht Spaß
			\item<8->Statisch typisiert
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<9->
      \begin{block}{Nachteile}
		\begin{itemize}
			\item<10->Komplex
			\item<11->Zukunftssicher?
			\note<11->{Ich glaube ja, und mittlerweile ist es auch keine Nische mehr. Wenn man aber darauf angewiesen ist, dass eine Technologie auch in 10 Jahren noch genauso vorhanden ist (was wahrscheinlich schlecht ist), dann muss man vielleicht den an sich schlechteren Mainstream wählen. Scala ist aber bei weitem nicht mehr esoterisch.}
			\item<12->Anzahl Entwicklungssklaven
			\note<12->{Es gibt eine Lernkurve, man braucht Entwickler, die Spaß daran haben und die Vorteile sehen wollen.}
			\item<13->Binärkompatibilität nicht in alle Ewigkeit
			\note<13->{Ist besser geworden, insbes. mit Java 8. Die Scala-Macher sind aber nicht so konservativ wie Oracle. Aber wozu das führt, haben wir ja gesehen.}
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{Scala -- Einsatzgebiete}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Geeignet}
		\begin{itemize}
			\item<3->Akka
			\item<4->Moderne Architekturen auf der JVM
			\item<5->(Statt Umstieg auf Node.js)
			\item<6->Tests für Java-Code
			\item<7->Hoher funtkionaler Anteil
			\item<8->Java als Sprache ablösen
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<9->
      \begin{block}{Weniger geeignet}
		\begin{itemize}
			\item<10->Scripting
			\item<11->Maschinennah
			\item<12->Spiele, Grafik, etc.
			\item<13->Umstieg auf JVM notwendig (F\# oder Swift)
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{}
  \begin{quote}
		{\large Weve found that Scala has enabled us to \alert{deliver things faster} with less code. Its reinvigorated the team.}
		\vskip3mm
		\hspace*\fill{\small--- Graham Tackley, Guardian}
	\end{quote}
	\note{Der Guardian ist der Inbegriff für den Technologiewandel in einer klassischen, behäbigen Branche. Lange, bevor Springer wach geworden ist.}
\end{frame}

\begin{frame}{}
	\begin{block}{Literatur}
		\begin{itemize}
			\item<2->Heiko Seeberger: "`Durchstarten mit Scala. Tutorial für Einsteiger"'
			\note<2>{Sehr angenehmes Einsteigerbuch, das nur an der Oberfläche kratzt, aber genügend zeigt, um arbeiten zu können.}
			\item<3->Martin Odersky: "`Programming in Scala"'
			\note<3>{Unglaublich detaillierte Vorstellung des Schöpfers. Lest das nicht zuerst, es erschlägt.}
			\item<4->Das Internet, nur ein Beispiel \texttt{https://twitter.github.io/scala\_school}
			% Todo: Mehr Referenzen, z.B. Präsentationen, Screencasts
		\end{itemize}
	\end{block}
	\note{
}
\end{frame}


% Abschlussfolie, leer und dunkel.
\plain{}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%
% Vorlagen
%%%%%%%%%%%%%%%%%%%%%%%
\appendix

% Notes
% Notes können innerhalb von Folien definiert und mit Overlays spezifiziert werden. Dann werden sie entsprechend zum Folienteil angezeigt.
% Nach der Folie definierte Notes werden der Folie zugeordnet, aber nur einmal - am Ende der Folie - ausgegeben.

% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


% Listing mit Header
\begin{frame}[fragile]{Primzahlen}
	\begin{block}{}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def swap(i: Int, j: Int) {
	val t = xs(i); xs(i) = xs(j); xs(j) = t
	()
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

% Listing mehrere Teile aufgedeckt
\begin{frame}[fragile]{}
	\begin{block}{}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
{
\onslide<3->
\begin{lstlisting}[firstnumber=5]

\end{lstlisting}
}
	\end{block}
	\note{}
\end{frame}

% Großer Text
\begin{frame}{}
	\Large\textbf{}
	\note{}
\end{frame}


% Einfacher Block
\begin{frame}{}
	\begin{block}{}
		
	\end{block}
	\note{}
\end{frame}


% Aufzählung
\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Vergleich
\begin{frame}{}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}

% Grafik Vollbild
\begin{frame}[plain]
   \begin{centering} 
     \pgfimage[height=\paperheight]{.PNG} 
     \par 
   \end{centering} 
\end{frame} 

% Grafik mit Überschrift
\begin{frame}[plain]
\begin{block}{Titel}
   \begin{centering} 
     \pgfimage[height=0.85\paperheight]{.png} 
     \par
   \end{centering}
	\end{block}
	\note{
	
	}
\end{frame} 

% Folie ausblenden
\begin{frame}<presentation:0>[fragile]{}
\end{frame}
