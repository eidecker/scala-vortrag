\documentclass[14pt,aspectratio=169]{beamer} %aspectratio=169 %aspectratio=43 % trans erzeugt Folien ohne Overlay
\usepackage[ngerman]{babel}
\usepackage[ansinew]{luainputenc}
\usepackage{listings}
\usepackage{pgfpages} % Second screen
\setbeameroption{hide notes} % show notes on second screen=bottom % hide notes % show notes % show only notes
\setbeamerfont{note page}{size=\tiny}


% Some colors
\definecolor{hBlue}{HTML}{004C99}
\definecolor{hBlack}{HTML}{555555}
\definecolor{hHeaderRed}{HTML}{E32119}
\definecolor{hBgLightBlue}{HTML}{E9E9E9}
\definecolor{hDarkBlue}{HTML}{00264C}

\definecolor{mDarkBrown}{HTML}{604c38}
\definecolor{mDarkTeal}{HTML}{23373b}
\definecolor{mLightBrown}{HTML}{EB811B}
\definecolor{mLightGreen}{HTML}{14B03D}

% Some styles for listings
\lstset{tabsize=2}
\lstdefinestyle{customscala}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Scala,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Java,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}

\lstset{style=customscala}

\usetheme[progressbar=foot, 
					numbering=none, 
					background=light,
					block=transparent]{metropolis} % block:fill
\setsansfont[BoldFont={Fira Sans},ItalicFont={Fira Sans Light Italic}]{Fira Sans Light}
\metroset{sectionpage=none} %sectionpage=progressbar

\setbeamercolor{normal text}{fg=hBlue, bg=black!2}
\setbeamercolor{alerted text}{fg=hHeaderRed}
\setbeamercolor{example text}{fg=mLightGreen}
\setbeamercolor{titlelike}{use=normal text, parent=normal text}
\setbeamercolor{author}{use=normal text, parent=normal text}
\setbeamercolor{date}{use=normal text, parent=normal text}
\setbeamercolor{institute}{use=normal text, parent=normal text}
\setbeamercolor{structure}{use=normal text, fg=normal text.fg}
\setbeamercolor{palette primary}{use=normal text, fg=normal text.bg, bg=normal text.fg}
\setbeamercolor{frametitle}{use=palette primary, parent=palette primary}
\setbeamercolor{progress bar}{use=alerted text, fg=alerted text.fg, bg=alerted text.fg!50!black!30}
\setbeamercolor{title separator}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in head/foot}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in section page}{use=progress bar, parent=progress bar}
%block transparent
\setbeamercolor{block title}{use=normal text, fg=hBlack, bg=}
\setbeamercolor{block body}{bg= }
\setbeamercolor{block body alerted}{use=block body, parent=block body}
\setbeamercolor{block body example}{use=block body, parent=block body}
\setbeamercolor{footnote}{fg=normal text.fg!90}
\setbeamercolor{footnote mark}{fg=.}

%% End color definition

% Subsectionpage
\AtBeginSubsection{\frame{\subsectionpage}}

\defbeamertemplate{subsection page}{progressbar}{
  \centering
  \begin{minipage}{22em}
    \raggedright
    \usebeamercolor[fg]{section title}
    \usebeamerfont{section title}
    \insertsectionhead\\[-1ex]
    \usebeamertemplate*{progress bar in section page}
    \par
    \ifx\insertsubsection\@empty\else%
      \usebeamercolor[fg]{subsection title}%
      \usebeamerfont{subsection title}%
      \insertsubsection
    \fi
  \end{minipage}
  \par
  \vspace{\baselineskip}
}

\setbeamertemplate{subsection page}[progressbar]
% End Subsectionpage

\usepackage{appendixnumberbeamer}
\usepackage[scale=2]{ccicons}
\usepackage{xspace}

\title{Scala (Programmiersprache)}
\subtitle{Ein Teaser und allgemeinere Gedanken}
\date{4. Mai 2016}
\author{Sebastian Eidecker}

\begin{document}

\maketitle




\begin{frame}{}
  \begin{quote}
		{\large\textbf{Wer als Werkzeug nur einen Hammer hat,\\sieht in jedem Problem einen Nagel.}}
		\vskip3mm
		\hspace*\fill{\small--- Paul Watzlawick}
	\end{quote}
	\note{
Ich möchte heute über Scala reden. Eigentlich will ich aber nicht nur über Scala reden.  Ich möchte nicht Scala verkaufen, sondern etwas völlig anderes. Scala ist spannend - für Nerds, die des Geldes wegen Java benutzen, denen aber mittlerweile Oracles Update-Politik nicht mehr gefällt. 
	
Ich will aber auch über aus meiner Sicht wichtigere Probleme reden. Und vielleicht passt Scala ja doch irgendwie.
	
In der IT wollen wir Probleme lösen und Möglichkeiten schaffen.
Ich bin der festen Überzeugung, dass wir zu selten über den Kern unserer Probleme nachdenken und auch, dass sich diese Probleme gerade ändern und immer schneller ändern werden.

Ich glaube daher, dass wir unser Problem \alert{und} unseren Werkzeugkasten kennen müssen. Ich glaube, dass wir zumindest wissen müssen, was im Baumarkt ausliegt und wir bei Bedarf einkaufen können. Daher kann es aus meiner Sicht nie schaden, sich neue Werkzeuge und Arbeitsweisen anzuschauen, damit man sie bei Bedarf zumindest im Hinterkopf hat. Sonst kann es passieren, dass wir das Problem gar nicht verstehen, weil wir kein passendes Werkzeug dafür besitzen und verwenden können.

}
\end{frame}


\begin{frame}<presentation:0>{}
	\begin{block}{Über mich}
		\begin{itemize}
			\item<2->Softwareentwickler
			\item<3->Enterprise-geschädigt
			\item<4->Java-geprägt
		\end{itemize}
	\end{block}
	\note{Erzählen, wer ich bin, was ich mache und warum das meine Sicht auf die IT-Welt und Scala massiv beeinflusst}
\end{frame}

\begin{frame}{}
	\setbeamertemplate{section in toc}[sections unnumbered]
	\begin{block}{Worüber will ich reden?}
		\vskip2mm
		\onslide<1->{\tableofcontents[pausesections,pausesubsections,subsubsectionstyle=hide]} %[hideallsubsections]}
	\end{block}
	\note{Ich will nicht nur über Scala reden. Da ich netterweise als erster Redner einer neuen Veranstaltung eingeladen wurde, möchte ich mir die Freiheit nehmen, etwas grundsätzlicher über die Softwareentwicklung zu reden.}
\end{frame}


\section{IT (mal wieder) im Wandel}

\subsection{Manifeste}
\note{Ein Manifest (lateinisch manifestus ‚handgreiflich gemacht‘) ist eine öffentliche Erklärung von Zielen und Absichten, oftmals politischer Natur. (Wikipedia)}

\begin{frame}{}
	\only<1>{\Large\textbf{Software Engineering}}\only<2>{\Large\textbf{Software \alert{Engineering}}}
	\note{Software Engineering. Passt der Begriff? Ich denke, dies impliziert zu stark, dass wir ein Problem nur lange genug durchdenken, exakt definieren und dann eine gute Lösung bauen müssen. Womöglich verstehe ich den Beruf des Ingenieurs falsch, aber ich glaube, wir haben gesehen, dass Software agil gebaut werden sollte, dass wir nicht zu Beginn eines Projektes alle Anforderungen exakt spezifizieren können. Und: Wir können kein System bauen, das hunderte Jahre stabil steht, wie eine Kirche oder Brücke. Wir müssen es ständig pflegen und verbessern, damit es nützlich bleibt.
	
}
\end{frame}


\begin{frame}{}
	\begin{block}{Reaktives Manifest (2013)}
		\begin{itemize}
			\item<2->Antwortbereit
			\item<3->Widerstandsfähig
			\item<4->Elastisch
			\item<5->Nachrichtenorientiert
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{}
	\begin{block}{Software Craftsmanship (2009)}
		\begin{itemize}
			\item<2->Gut gefertigte Software
			\item<3->Stets Mehrwert schaffen
			\item<4->Gemeinschaft aus Experten bilden
			\item<5->Produktive Partnerschaften mit Kunden
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{}
	\begin{block}{Agiles Manifest (2001)}
		% Todo: Ausführlicher, die Punkte sind wichter als...
		\begin{itemize}
			\item<2->Individuen und Interaktionen mehr als Prozesse und Werkzeuge
			\item<3->Funktionierende Software mehr als umfassende Dokumentation
			\item<4->Zusammenarbeit mit dem Kunden mehr als Vertragsverhandlung
			\item<5->Reagieren auf Veränderung mehr als das Befolgen eines Plans
		\end{itemize}
	\end{block}
\end{frame}

\note{Es gibt Manifeste von Softwareentwicklern, die sehr Ähnliches aussagen. (Reaktives Manifest, agiles Manifest, Manifest der Software Craftmanship-Bewegung als Beispiele) Diese sind bekannt und -- ich habe zumindest das Gefühl -- auch anerkannt. Ich will auch nur sehr kurz darauf eingehen, es soll ja vor allem um Scala gehen.

Im Grunde geht es überall darum, gemeinsam Software zu entwickeln, dabei die Bedürnisse des Kunden aktiv zu erforschen und möglichst zuverlässige und nützliche Software zu erstellen.
}

\begin{frame}{}
	\only<1>{\Large\textbf{Nur Manifeste?}}
	\only<2>{\Large\textbf{Realitätsabgleich}}
	\note{Erst einmal nur Manifeste. Sie stammen jedoch von Praktikern. Also schauen wir mal in die aktuelle Welt. Ich denke nämlich, die Anforderungen und die Rolle der IT ändern sich gerade dramatisch.
	
	}
\end{frame}

% Todo: Folie mit Belegen für IT im Wandel, z.B. Werbung adesso Codecentric
% Vier Sektoren
% Beispiele: Uber, Amazon, ...

\subsection{Anforderungen und Rolle der IT}

\begin{frame}{}
	\only<1>{\Large\textbf{Vier-Sektoren-Hypothese}}
	\note{
	
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Mobile first -- Mobile only}}
	\note{
	
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Internet of things}}
	\note{
	
	}
\end{frame}


\begin{frame}{}
	\only<1>{\Large\textbf{Rasante Releasezyklen}}
	\note{DevOps. Wir brauchen Sicherheit
	
	}
\end{frame}


\begin{frame}{}
  \begin{quote}
		{\Large\textbf{Software is eating the world}}
		\vskip3mm
		\hspace*\fill{\small--- Marc Andreesen, 2011}
	\end{quote}
	\note{Bei Marc Andreesen gipfelt es in dem Satz ...
% Todo: Genaue Bedeutung: http://genius.com/Marc-andreessen-why-software-is-eating-the-world-annotated
	}
\end{frame}

\begin{frame}{}
	\only<1>{\Large\textbf{Google, Amazon, Uber, Facebook}}
	\only<2->{\Large\textbf{Wer baut in 30 Jahren Autos?\\}}
	\only<3->{\Large\textbf{Mit welchem Geschäftsmodell?}}
	\note{Vielleicht: Uber lässt von Google Autos bauen, nutzt deren Karten und bietet selbst fahrende Taxis?
	
	}
\end{frame}




% Todo: Raus, da Hellmann-Interna? Stattdessen öffentliche Quelle suchen
\begin{frame}{}
	\begin{block}{Konkrete Forderungen des Business}
		\begin{itemize}
			\item<2->Stabilität und Resilienz
			\note<2>{Sorgen sie durch ihre Arbeit dafür, dass Systeme Kriterien der Stabilität und Resilienz erfüllen.
			Seien sie "`dran"' an den Problemen, antizipieren sie sie, schaffen sie Fall-Back-Lösungen -- auch an Wochenenden.
			
			}
			\item<3->Wertbeitrag
			\note<3>{IT entwickelt sich zunehmend zu einem eigenen Produktionsfaktor (4-Sektor-Hypothese).
			Seien sie ein verlässlicher Partner für das Business, nehmen sie die Business-Seite auch an die Hand, helfen und unterstützen sie, leisten sie einen wahrgenommenen Wertbeitrag.[...]
			
			}
			\item<4->Businesstreiber
			\note<4>{Die Entwicklung der IT treibt zunehmend die Business-Seite und verändert Geschäftsmodelle.
			Seien sie an der Front und treiben sie das Business, entwickeln sie neue Ideen, forschen sie nach neuen Lösungen (Beispiele: Uber, 3D-Printing, CoLo21, ...
			
			}
		\end{itemize}
		\onslide<5->{\vskip3mm --- CEO eines Logistik-Dienstleisters}
		\note<5->{Das Bewusstsein, dass ein Wandel stattfindet, ist im Business angekommen!}
	\end{block}
\end{frame}


\begin{frame}{}
	\only<1>{\Large\textbf{Unsere Projekte}}\only<2>{\Large\textbf{Unsere Projekte -- \alert{Was sehen wir davon?}}}
	\note{Passt das? Haben wir ähnliche Herausforderungen? Haben wir diese schon gelöst?
	
	}
\end{frame}


\section{Scala}

\subsection{Management Summary}

\begin{frame}{}
	\Large\textbf{\alert{Sca}}lable \textbf{\alert{La}}nguage
	\only<2->{
	\vskip3mm
	\begin{quote}
		{\normalsize This means that Scala grows with you. You can play with it by typing \alert{one-line expressions} and observing the results. But you can also rely on it for \alert{large mission critical systems} [...]}
		\vskip3mm
		\hspace*\fill{\small--- www.scala-lang.org}
	\end{quote}
	}
	\note{Was bedeutet das? Scala ist sehr flexibel. Es vereint sehr viele Konzepte und ist im API-Design sehr stark. So sollen unterschiedlichste Szenarien und Anforderungen bedient werden. Schauen wir, ob das Versprechen gehalten wird.
	
	}
\end{frame}


\begin{frame}{}
	\begin{block}{Eigenschaften}
		\begin{itemize}
			\item<2->Objektorientiert
			\note<2>{Keine Primitive, wie in Java. Ein schönes Beispiel: Dort hat man per Autoboxing Komplexität eingeführt statt Schönheit. NullPointer bei Primitiven anyone?}
			\item<3->Funktional
			\item<4->Statisch typisiert mit Type Inference
			\note<4>{Aber Type Inference, wenn gewünscht}
			\item<5->Immutable by default
			\item<6->Gewohnte Syntax ("`Java ohne Semikolon"')
			\item<7->Ausdrucksstark (APIs/DSLs)
			\note<7>{Bei Java bricht man sich schon die Hände, will man ein Builder-Pattern rekursiv umsetzen oder eine fluent API}
			\item<8->Jung (2004, Hype 2011)
		\end{itemize}
	\end{block}
\end{frame}
\note{}

\begin{frame}{}
	\begin{block}{Versprechen}
	\begin{itemize}
		\item<2->Produktivitätssteigerung
		\item<3->Höhere Codequalität
		\item<4->Mehr Spaß
		\note<4>{REPL, habe ich mir für Java schon immer gewünscht. Wer hat keine Testklasse, um mal etwas auszuprobieren?}
		\item[]<5->\alert{durch}
		\item<5->Weniger Code
		\item<6->Höheres Abstraktionsniveau
		\item<7->Skalierbarkeit
	\end{itemize}
	\end{block}
\end{frame}
\note{Passt in unseren Entwicklungsprozess. Leichte Änderungen an Deployment etc.

}


\subsection{Entwicklungsumgebung}
\note{Wie sieht die Entwicklung mit Scala aus}

\begin{frame}{}
	\begin{block}{Scala und die Java-Plattform}
		\begin{itemize}
			\item<2->Java-Bytecode, läuft auf JVM
			\item<3->Java-Bibliotheken nutzbar
			\item<4->Bekannte IDEs
			\note<4,5>{Wenn man schon eine neue Sprache lernt, wird man wenigstens bei IDE und Buildprozess abgeholt.}
			\item<5->Ähnliches Toolset, oft wiederverwendbar
			\item<6->Projektstruktur wie Maven
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\begin{frame}{}
	\begin{block}{IDE-Unterstützung}
		\begin{itemize}
			\item<2->Die üblichen Verdächtigen 
			\item<3->"'Richtige"' IDEs: IntelliJ, Eclipse, Netbeans
			\item<4->Plugins für Editoren: Emacs, vi, ...
			\item<5->Mittlerweile sehr ordentlich
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Todo
\begin{frame}{}
	\begin{block}{SBT  -- Scala build tool}
		\begin{itemize}
			\item<2->Buildtool für Scala-Projekte
			\item<3->Auch interaktiv (REPL -- Read eval print loop)
			\item<4->Projektdefinition in Konfigurationsdatei
			\item<5->scalac und scala natürlich auch
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

% Todo
\begin{frame}{}
	\begin{block}{Continuous Integration}
		\begin{itemize}
			\item<2->SBT-Plugins für Jenkins/Bamboo
			\item<3->Unit-Tests: Scalatest
			\item<4->Statische Codeanalyse: ScalaStyle
			\item<5->Tools für die JVM funktionieren
		\end{itemize}
	\end{block}
	\note{Also alles wie gewohnt
	
	}
\end{frame}

% Großer Text
\begin{frame}<presentation:0>{}
	\Large\textbf{REPL-Demo}
	\note{}
\end{frame}

% REPL-Demo und Scratchpad in 
\note{REPL-Demo und Scratchpad IntelliJ}
\plain{}

% Todo
\begin{frame}[fragile]{}
	\begin{block}{Buildfile}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{Definiert die grundlegende Konfiguration unseres Projektes, mit deren Hilfe SBT das Projekt bauen kann}
\end{frame}


\subsection{Code}
\note{Vieles geklaut von Wikipedia oder Heiko Seebergers Buch}

\begin{frame}{}
	\begin{block}{Schnelldurchlauf Scala -- \alert{Endlich!}}
		\begin{itemize}
			\item<2->Wichtige Bereiche
			\item<3->Von einen Java-Entwickler ausgesucht
			\item<5->Keine Vollständigkeit
			\item<6->Ziel: Charakter der Sprache zeigen
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\subsubsection**{Einführendes Beispiel und Gegenbeispiel}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<2->
  \begin{lstlisting}
public class Person {
	private final String firstName;
	private final String lastName;
	public Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
					}
	public String getFirstName() {
			return firstName;
	}
	public String getLastName() {
			return lastName;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=14]
	@Override
	public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Person person = (Person) o;
			if (firstName != null ? 
					!firstName.equals(person.firstName) : 
					person.firstName != null) return false;
			if (lastName != null ? 
					!lastName.equals(person.lastName) : 
					person.lastName != null) return false;
			return true;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=27]
	@Override
	public int hashCode() {
			int result = firstName != null ? firstName.hashCode() : 0;
			result = 
					31 * result + (lastName != null ? lastName.hashCode() : 0);
			return result;
	}
}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
	\Large\textbf{Businesslogik?}
	\note{Wo ist die Businesslogik versteckt? Ich gebe zu, das wird nur ein Beispiel, aber es zeigt symptomatisch eine Schwäche von Java: 
Java ist leicht verständlich, Änderungen werden aber immer non-breaking eingeführt und fühlen sich oft deplatziert an.
Scala hat den Vorteil, neuer zu sein und kennt die Schmerzen der Java-Entwickler. Daher sind viele Dinge eingebaut, die man sich schon lange wünscht 
oder Konzepte, die man eigentlich schon immer umsetzen wollte, wenn es denn nicht so lästig wäre.
(Immutable Objects, Lambdas, Generics, checked Exceptions als Beispiel)

Ein besonders lästiges Nicht-Feature-Feature sind in meinen Augen JavaBeans, wie wir sie gerade gesehen haben. Leicht verständlich, aber strikte Richtlinien durch Konvention. Und wehe, dein Framework mag die Namen Deiner Getter und Setter nicht.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Dasselbe in Scala}
\small
	\onslide<2->
  \begin{lstlisting}
case class Person(firstName:String, lastName:String)
	\end{lstlisting}
\end{block}
\note{Ja, nur ein Beispiel, ein besonders krasses. Aber dennoch ein alltägliches.}
\end{frame}



% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{Es wird funktional -- Quicksort}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def quickSort[A <% Ordered[A]](xs: List[A]): List[A] = xs match {
  case Nil     => xs
  case y :: ys => ys partition (_ <= y) match {
    case (l1, l2) => quickSort(l1) ++ (y :: quickSort(l2)) 
	}
}
	\end{lstlisting}
\end{block}
\note{Man sieht: Ausdrucksstark, aber auch nicht mehr so straight forward wie Java (vor 8). Scala ist beides: Sehr einfach und fast beliebig komplex. Und dieser Quicksort ist noch lange nicht das Ende der Möglichkeiten.

}
\end{frame}

?\begin{frame}[fragile]{}
\begin{center}
	\includegraphics[width= 0.8\paperwidth]{Scala-Madness.PNG}
\end{center}
\note{Man sieht: Ausdrucksstark, aber auch nicht mehr so straight forward wie Java (vor 8). Scala ist beides: Sehr einfach und fast beliebig komplex.

}
\end{frame}



\subsubsection**{Variablen}

\begin{frame}[fragile]{}
 \begin{block}{Variablen -- val und var}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
var j = 3
j = 4
\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
val k = 3
k = 4
\end{lstlisting}
\end{block}
\onslide<4->Compile-Fehler für k, da immutable
\onslide<5->
\begin{lstlisting}[firstnumber=5]
val k: Int = 3
	\end{lstlisting}
\note{val ist Default. Typen kann man auch angeben}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Methoden}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f = 3 * 2

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
def f(): Int = 3 * 2

	\end{lstlisting}
	\onslide<4->
  \begin{lstlisting}[firstnumber=3]
def f(i: Int) = 3 * i
	\end{lstlisting}
	\onslide<5->
  \begin{lstlisting}[firstnumber=4]
def f(i: Int) = {
	3 * i
}
	\end{lstlisting}
\end{block}
\note{Hier mal eine Methode. Mit = definiert. Methoden können mehr als in Java, dazu später.
Die Klammern kann man sich sparen, wenn 
Typen kann man angeben, muss es aber nicht, so lange der Compiler sie ermitteln kann. 
Bei öffentlichen Methoden sollte man es aber tun, dann hat der Nutzer auch eine reelle Chance.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Implizites return}
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    "B"
}
	\end{lstlisting}
\end{block}
\onslide<3->{Letzte Anweisung wird zurückgegeben, impliziter Typ String.}
\note{
Kein return, letzte Anweisung wird zurückgegeben. Alles hat einen Typen!
Die Methode ist statisch typisiert! Der Compiler kann den Typen der Rückgabe ermitteln: String -- Type Inference
Wenn wir wollen, können wir ihn deklarieren. Bei öffentlichen Methoden sollte man das auch tun.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Type Inference -- Any}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    1
}
	\end{lstlisting}
\end{block}
\onslide<3->
Erste gemeinsame Oberklasse, zur Not Any
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Unit}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def print(s: String): Unit = println(s)
	\end{lstlisting}
\end{block}
\note{Wollen wir mal wirklich nichts zurückgeben, so existiert der Typ Unit. Sinnvoll bei Methoden, die ausschließlich Seiteneffekte haben. Sollte also selten sein.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Parameter sind vals}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def addOne(i: Int): Int = { i += 1; i }
	\end{lstlisting}
\end{block}
\onslide<3->Compile-Fehler, da i immutable
\note{i ist val per Default, also immutable. Letzter Ausdruck ist return}
\end{frame}

% Präsentation: Alles ist ein Typ im Scratchpad. Das ist aus meiner Sicht praktisch
\plain


\subsubsection**{Listen}

\begin{frame}[fragile]{}
 \begin{block}{Listen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val bagContent = List(1, "a", Time(12,30), 4)
	\end{lstlisting}
\end{block}
\onslide<4->
Immutable-Listen bevorzugen
\note{Einfache Erstellung von Listen. Type Inference auch hier, zweite ist Liste von Any. Collections gibt es immer auch Immutable, die auch schnell sind.

}
\end{frame}

\subsubsection**{Collection-Struktur}
% Todo: Struktur, Immutables
% Anwendungsbeispiele, auch Maps
\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\begin{frame}[fragile]{}
	\begin{block}{Collections}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Listen verketten und auseinanderreißen}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
++ +:

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}



\subsubsection*{Funktionen höherer Ordnung}

\begin{frame}[fragile]{}
 \begin{block}{Funktionen höherer Ordnung}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val numbersDecreasing = numbers.sortWith((x, y) => x > y)	
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusOne = numbers.map(x => x + 1)
\end{lstlisting}
\end{block}
\note{Funktionen können als Parameter übergeben werden. Auch die Funktion ist ein Objekt.
Kennt man in Java mittlerweile auch, wirkt aber aus meiner Sicht nicht so schön integriert.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Funktionen als Typen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbersPlusOne = numbers.map(x => x + 1)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val addTwo = (n: Int) => n + 2
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusTwo = numbers.map(addTwo)

\end{lstlisting}
\onslide<5->
  \begin{lstlisting}[firstnumber = 4]
val descending = (n: Int, m: Int) => n > m
\end{lstlisting}
\onslide<6->
  \begin{lstlisting}[firstnumber = 5]
val sortedNumbers = numbers.sortWith(descending)
\end{lstlisting}

\end{block}
\note{Wir können Funktionen auch wie Variablen verwenden und übergeben. Es sind first class citizens. Und das ist mächtig. Das sehen wir schon in Java 8, aber in Scala war es schon immer und wird bereits fleißig in APIs genutzt. Das macht es für Programmierer, die keinen funktionalen Background haben, leider auch nicht einfacher. Methoden sind übrigens keine Objekte (Methode per def, Funktion per val deklariert.)
Methode in Funktion umwandeln
def addOne(n: Int) = n+1
val f = addOne \_

addOne kann dennoch übergeben werden, da Compiler die Arbeit übernimmt.

}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Partition}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val people: Array[Person]
    
val (minors, adults) = people partition (_.age < 18)
	\end{lstlisting}
	\end{block}
	\note{val people: Array[Person]
    // Partition `people` into two arrays `minors` and `adults`.
    // Use the higher-order function `(_.age < 18)` as a predicate for partitioning.
    val (minors, adults) = people partition (_.age < 18)}
\end{frame}

    

% Todo: %http://docs.scala-lang.org/tutorials/tour/anonymous-function-syntax
\begin{frame}[fragile]{}
	\begin{block}{Anonyme Funktionssyntax}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Klassen und Objekte}

\begin{frame}[fragile]{}
 \begin{block}{Klassen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int, val minutes: Int) {
  // Primärer Konstruktor
  require(hours < 24 && hours >= 0)
  require(minutes < 60 && minutes >= 0)
	
	def this() = this(0)
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=8]
val t = new Time(1, 14)
val t2 = new Time
	\end{lstlisting}
\end{block}
\note{Der Standardkonstruktor für alle Parameter ist direkt im Methodenrumpf. Hilfskonstruktoren sind möglich.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Benannte Parameter und Standardwerte}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int = 0, val minutes: Int = 0)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val t = new Time(1)
val t2 = new Time(minutes = 13)
	\end{lstlisting}
\end{block}
\note{Damit werden Argumentnamen aber auch API-Bestandteil und dürfen nicht geändert werden.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Singleton/Companion Objects}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
object Time {
	def fromMinutes(minutes: Int): Time = 
			new Time(minutes / 60, minutes % 60)
}

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val t = Time.fromMimutes(100)
	\end{lstlisting}
\end{block}
\note{Companion Objects sind Singleton Objects. Sie existieren nur ein mal. "`Ersatz"' für static, das es nicht gibt. Companion Objects (selber Name, selbes Paket, selbe Datei wie Klasse) können auf private Elemente der Klasse zugreifen

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Case classes}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Person(nachname: String, vorname: String)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val ich = Person("Eidecker", "Sebastian")
val sohn = ich.copy(vorname = "Nils")
	\end{lstlisting}
\end{block}
\note{Case classes sind JavaBeans in schön. Nehmen die üblichen Dinge ab, die sowieso die IDE macht. Ideal als DTO, man kann/sollte aber nicht von ihnen erben. Hübscher "`Konstruktor"', Copy-Konstruktor und toString

}
\end{frame}


\subsubsection*{Vererbung}

\begin{frame}[fragile]{}
 \begin{block}{Vererbung und Traits}
\begin{itemize}
	\item<2->Geht
	\item<3->Mehrfachvererbung durch Traits
	\item<4->Weniger strukturell, eher funktionaler als in Java
\end{itemize}
\end{block}
\note{Ähnlich Java in den Grundzügen. Mit Traits Mehrfachvererbung möglich und funktionalerer Ansatz. Dadurch häufig kleinere Funktionsblöcke in Traits. Java 8 bietet mit default-Methoden in Interfaces ähnliches.

}
\end{frame}



% Todo
\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Traits}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
abstract class Spacecraft {
	def engage(): Unit
}
trait CommandoBridge extends Spacecraft {
	def engage(): Unit = {
		for (_ <- 1 to 3)
			speedUp()
	}
	def speedUp(): Unit
}
trait PulseEngine extends Spacecraft {
	val maxPulse: Int
	var currentPulse: Int = 0
	def speedUp(): Unit = {
		if (currentPulse < maxPulse)
			currentPulse += 1
	}
}
class StarCruiser extends Spacecraft
										 with CommandoBridge
										 with PulseEngine {
	val maxPulse = 200
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{Vererbung}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Operatorendefinition}

\begin{frame}[fragile]{}
 \begin{block}{Schönere Methodenaufrufe}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
"Test".startsWith("T")
List(1,2,3).isEmpty
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}
"Test" startsWith "T"
List(1,2,3) isEmpty
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Definition eigener Operatoren}
\scriptsize
\begin{overlayarea}{\textwidth}{4cm}
	\begin{onlyenv}<2-4>
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}

}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<5->
	\begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}
  def -(time: Time) = minus(time)
}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<3>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))

			
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<4-5>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)

	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<6->
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)
Time(10,20) - Time(1,10)
	\end{lstlisting}
	\end{onlyenv}
	\end{overlayarea}
\end{block}
\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{For-Ausdrücke}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val times = List(Time(12,0), Time(13,0), Time(14,0))

for {
  time <- times
  minutes = time.hour * 60
} yield minutes
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 7]
List[Int] = List(720, 780, 840)
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Schleifen}
\begin{frame}[fragile]{}
	\begin{block}{While}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\begin{frame}[fragile]{}
	\begin{block}{For}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Pattern Matching}

\begin{frame}[fragile]{}
 \begin{block}{Pattern Matching}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)
   
for (person <- List(alice, bob, charlie)) {
	person match {
		case Person("Alice", 25) => println("Hallo Alice!")
    case Person("Bob", 32) => println("Hallo Bob!")
    case Person(name, age) => println("Alter: " + alter + ", Name: " + name)
  }
}
	\end{lstlisting}
\end{block}
\note{Sehr mächtiges Feature. Code wirkt auf einmal sinnvoll. Java-Case auf Steroids ist noch zu schwach. Vielfältige Pattern möglich. Dabei Aufspalten von Listen möglich, siehe Quicksort.
Bekannt aus rein funktionalen Sprachen.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Pattern Matching -- Funktional Länge einer Liste}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def length[A](list : List[A]) : Int = {
  list match {
    case _ :: tail => 1 + length(tail)
    case Nil => 0
  }
}
	\end{lstlisting}
\end{block}
\note{Liste wird in Head und tail geteilt per :: Dann rekursiv weiter
Da fühlt sich der Compiler-Entwickler foch schon fast abgeholt.

}
\end{frame}


%Todo: - Patterm Matching mit _
% Verschiedene Matching-Möglichkeiten darstellen

\begin{frame}[fragile]{}
	\begin{block}{Matcher}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{yield}
\begin{frame}[fragile]{}
	\begin{block}{Yield}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Rekursion (tailrec)}

\begin{frame}[fragile]{}
 \begin{block}{@tailrec}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def factorial(n: Int): Int = {
  if (n <= 1) 1
  else n * factorial(n - 1)
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 5]
def factorialTail(n: Int): Int = {
  @tailrec
  def factorialAcc(acc: Int, n: Int): Int = {
    if (n <= 1) acc
    else factorialAcc(n * acc, n - 1)
  }
  factorialAcc(1, n)
}
	\end{lstlisting}
\end{block}
\note{Es müssen keine Ergebnisse zwischengespeichert werden. Optimierung durch den Compiler. Warnung, wenn nicht tail recursive.
https://myadventuresincoding.wordpress.com/2010/06/20/tail-recursion-in-scala-a-simple-example/

Praktisch: Man kann Funktionen verschachteln.
}
\end{frame}

\subsubsection*{Tupel}

\begin{frame}[fragile]{}
 \begin{block}{Tupel}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val ichMitAlter = (Person("Eidecker", "Sebastian"), 37)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val ich = ichMitAlter._1
val alter = ichMitAlter._2

	\end{lstlisting}	
	\onslide<4->
  \begin{lstlisting}[firstnumber=4]
def personMitAlter(person: Person, alter: Int): (Person, Int) = {
	(person, alter)
}
\end{lstlisting}
\end{block}
\note{Tupel können nützlich sein, wenn man mal kein neues Objekt erstellen will. Oder, wenn man Maps verwendet. Oder, wenn man Funktionen als Parameter übergibt. Oder, wenn man Compiler baut.

}
\end{frame}

\subsubsection*{???}

\begin{frame}[fragile]{}
 \begin{block}{??? -- Mein heimlicher Star}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {

  def minus(time: Time) = ???
	
}
	\end{lstlisting}
\end{block}
\onslide<3->{Kompilierbar, aber nicht gefährlich.}
\note{Kompiliert, beim Aufruf aber Exception. Hilfreich, wenn man test first entwickelt. Dann jammert der Compiler nicht ständig.}
\end{frame}

\subsubsection*{Arbeiten mit Strings}

\begin{frame}[fragile]{}
	\begin{block}{Arbeiten mit Strings}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Implicits / Implicit conversion}

\begin{frame}[fragile]{}
	\begin{block}{Implicits -- Wenn man nichts mehr versteht}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Futures}

\begin{frame}[fragile]{}
	\begin{block}{Futures}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
val x = future { someExpensiveComputation() }
val y = future { someOtherExpensiveComputation() }
val z = for (a <- x; b <- y) yield a*b
for (c <- z) println("Result: " + c)
println("Meanwhile, the main thread goes on!")
	\end{lstlisting}
	\end{block}
	\note{In Scala, futures and promises can be used to process data asynchronously, making it easier to parallelize or even distribute your application.

In this example, the future{} construct evaluates its argument asynchronously, and returns a handle to the asynchronous result as a Future[Int]. For-comprehensions can be used to register new callbacks (to post new things to do) when the future is completed, i.e., when the computation is finished. And since all this is executed asynchronously, without blocking, the main program thread can continue doing other work in the meantime. }
\end{frame}

\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\subsubsection*{Option}

% Verwendung
\begin{frame}{}
	\begin{block}{Besondere Typen -- Option, Some, None}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ab hier Streichkandidaten
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Langweiligeres ab hier}
\subsubsection*{Exception Handling}

\subsubsection*{Verschachtelte Funktionen}
\begin{frame}[fragile]{}
	\begin{block}{Verschachtelte Funktionen}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def factorial(n: Int): Int = {

  def factorialAcc(acc: Int, n: Int): Int = {
    if (n <= 1) acc
    else factorialAcc(n * acc, n - 1)
  }
	
  factorialAcc(1, n)
}
	\end{lstlisting}
	\end{block}
	\note{Praktisch bspw. für rekursive Funktionen. Haben wir dort schon gesehen.}
\end{frame}

% Todo
\begin{frame}[fragile]{}
	\begin{block}{Exceptions}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
try {
  val f = new FileReader("input.txt")
} catch {
  case ex: FileNotFoundException => {
    println("Missing file exception")
  }
  case ex: IOException => {
    println("IO Exception")
  }
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

% Todo
\begin{frame}{}
	\begin{block}{Exceptions}
		\begin{itemize}
			\item<2->Wie in Java
			\item<3->Pattern Matching
			\item<4->Selten: Option oder Either nutzen
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Annotationen}

\begin{frame}[fragile]{}
	\begin{block}{Annotationen}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Predef}

\begin{frame}[fragile]{}
	\begin{block}{Predef}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}

	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}

\subsubsection*{Und viel, viel mehr}
\begin{frame}{}
	\Large\textbf{Und noch viel, viel mehr ...}
	\note{Insbesondere im Bereich der funktionalen Programmierung. Aber dafür haben wir leider keine Zeit. Und ich kenne auch bwi weitem nicht alles.
	
	}
\end{frame}


\subsection{Spannendes aus dem Ökosystem}

\subsubsection*{Domain Specific Languages}

\begin{frame}{}
	 \begin{block}{Domain Specific Languages}
			 \begin{itemize}
				 \item<2->Fachliche Abstraktion
				 \item<3->Verständlicher
				 \item<4->Entwicklung schwierig
				 \item<5->Einschränkungen vorhanden
				\note<5->{Gegenüber externen DSLs wie Xtext, die beliebige Syntax erlauben}
			 \end{itemize}
	 \end{block}
	 \note{}
\end{frame}


\begin{frame}<presentation:0>[fragile]{}
 \begin{block}{DSL -- Beispiel}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
100 PRINT "Distance " % 'dist % "km, " % "Velocity " % 'v % "km/s, " % "Fuel " % 'fuel
110 INPUT 'burn
120 IF ABS('burn) <= 'fuel THEN 150
130 PRINT "You don't have that much fuel"
140 GOTO 100
150 LET ('v := 'v + 'burn * 10 / ('fuel + 'mass))
	\end{lstlisting}
\end{block}
\note{Ist natürlich Quatsch, zeigt aber, was geht. Und wir kommen auch gleich }
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Scalatest}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
"Creating a Time" should {
    "throw an IllegalArgumentException for hours less than 0 or greater equal 24" in {
      forAll("hours") { (hours: Int) =>
        whenever(hours < 0 || hours >= 24) {
          an[IllegalArgumentException] should be thrownBy Time(hours)
        }
      }
    }
  }
	\end{lstlisting}
\end{block}
\note{DSLs sind sinnvoll, wenn sie besser zum Ausdruck bringen, was in der Domäne beschrieben wird.

}
\end{frame}

\subsubsection*{Aktoren und Akka}

\begin{frame}{}
	\begin{block}{Aktoren}
		\begin{itemize}
				\item<2->Nebenläufige Einheiten
				\item<3->Empfangen Nachrichten (Ereignisse)
				\item<4->Abarbeitung FIFO
				\item<5->Verhaltensänderung
				\item<6->Asynchrone Kommunikation mit Aktoren
			\end{itemize}
	\end{block}
	\note{Kommen wir zu etwas wirklich Spannenden. Ich habe davon zugegeben kaum Ahnung, finde es aber so interessant, dass ich es heute erzählen muss!
	
	The Actor Model, which was first proposed by Carl Hewitt in 1973 [5] and was improved, among others, by Gul Agha [6]. This model takes a different approach to concurrency, which should avoid the problems caused by threading and locking.

In the actor model, each object is an actor. This is an entity that has a mailbox and a behaviour. Messages can be exchanged between actors, which will be buffered in the mailbox. Upon receiving a message, the behaviour of the actor is executed, upon which the actor can: send a number of messages to other actors, create a number of actors and assume new behaviour for the next message to be received.

Of importance in this model is that all communications are performed asynchronously. This implies that the sender does not wait for a message to be received upon sending it, it immediately continues its execution. There are no guarantees in which order messages will be received by the recipient, but they will eventually be delivered.

A second important property is that all communications happen by means of messages: there is no shared state between actors. If an actor wishes to obtain information about the internal state of another actor, it will have to use messages to request this information. This allows actors to control access to their state, avoiding problems like the lost-update problem. Manipulation of the internal state also happens through messages.

Each actor runs concurrently with other actors: it can be seen as a small independently running process.

Das ist ähnlich der reinen Objektorientierung, aber komplett asynchron. Die Idee ist übrigens alt (1973) und schon lange, z.B. in Erlang im Einsatz. Momentan passen die Probleme aber.
	http://www.brianstorti.com/the-actor-model/
	
	
}
\end{frame}


\begin{frame}{}
	\begin{block}{Akka}
		\begin{itemize}
			\item<2->Aktoren
			\note<2>{Klar, sonst hätte es die vorherige Folie nicht gegeben.
			Actors give you:
Simple and high-level abstractions for concurrency and parallelism.
Asynchronous, non-blocking and highly performant event-driven programming model.
Very lightweight event-driven processes (several million actors per GB of heap memory).

}
			\item<3->Fehlertoleranz
			\note<3>{
    Supervisor hierarchies with "let-it-crash" semantics.
    Supervisor hierarchies can span over multiple JVMs to provide truly fault-tolerant systems.
    Excellent for writing highly fault-tolerant systems that self-heal and never stop.

}
			\item<4->Standort-Transparenz
			\note<4>{Everything in Akka is designed to work in a distributed environment: all interactions of actors use pure message passing and everything is asynchronous.}
			\item<5->Nachrichten-Persistenz
			\note<5>{Messages received by an actor can optionally be persisted and replayed when the actor is started or restarted. This allows actors to recover their state, even after JVM crashes or when being migrated to another node.
			
			}
			\item<6->Reaktiv laut Manifest
		\end{itemize}
	\end{block}
	\note{Was bringt uns das nun: Ziemlich viel von dem, was moderne verteilte Systeme leisten sollten.
	
	}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case object PingMessage
case object PongMessage
case object StartMessage
case object StopMessage

class Ping(pong: ActorRef) extends Actor {
  var count = 0
  def incrementAndPrint { count += 1; println("ping") }
	\end{lstlisting}
\end{block}
\note{http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example
Nachrichten mit Case-Klassen, einfacher geht es nicht. Und typsicher, was mir persönlich gut gefällt.
Ein Aktor hat einen Zustand und vor allem eine receive-Methode.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=9]
  def receive = {
    case StartMessage =>
        incrementAndPrint
        pong ! PingMessage
    case PongMessage => 
        incrementAndPrint
        if (count > 99) {
          sender ! StopMessage
          println("ping stopped")
          context.stop(self)
        } else {
          sender ! PingMessage
        }
  }
}
	\end{lstlisting}
\end{block}
\note{In der receive-Methode wird das Verhalten implementiert.
http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Pong-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=19]
class Pong extends Actor {
  def receive = {
    case PingMessage =>
        println("  pong")
        sender ! PongMessage
    case StopMessage =>
        println("pong stopped")
        context.stop(self)
  }
}
	\end{lstlisting}
\end{block}
\note{Und hier das Gegenstück:
Ein einfaches Beispiel, aber man sieht, wie hier Nachrichten ausgetauscht werden. Das soll hier aber keine Akka-Schulung sein, die ich auch nicht halten könnte, sondern
eine Idee geben, warum Scala geeignet sein könnte, Aktoren zu implementieren.

Aktoren, die Daten empfangen, evtl. Zustand halten, die Daten verarbeiten und Nachrichten weiterschicken.
Das ganze hochparallelisiert, die Nachrichten werden sicher gespeichert.
Ich kann mir nicht helfen, aber das liest sich für mich wie ein Business-Prozess. Den man beliebig zusammenstecken kann. Und er funktioniert dennoch, weil man in der Programmiersprache dasselbe macht wie in einem EPK oder BPMN-Modell. (Disclaimer: Ich habe es noch nicht viel weiter als bis zu diesem Niveau ausprobiert, aber Menschen, die es getan haben, stimmen darin überein).

Und mit Scala (vor allem Pattern Matching) bricht man sich bei der Implementierung auch nicht die Finger.

}
\end{frame}

\subsubsection*{Akka HTTP}

% Großer Text
\begin{frame}{}
	\Large\textbf{Akka HTTP}
	\note{}
\end{frame}

% Todo
\begin{frame}{}
	\begin{block}{Einsatzmöglichkeiten}
		\begin{itemize}
			\item<2->Start, Stop, Nachrichten, Zustand
			
			\item<4->Nebenläufig, skalierbar, resilient durch Akka
			\item[]<5->
			\item<5->Mein Traum: Direkte Abbildung
			\item<6->Scheint machbar
			\item<7->Umgewöhnung
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Warum in Scala?}
		\begin{itemize}
			\item<2->Pattern Matching
			\item<3->Funktional
			\item<4->Weniger Code
			\item<5->Besser verständlich
		\end{itemize}
	\end{block}
	\note{Akka kann man auch mit Java umsetzen. Aber insbesondere das Pattern Matching macht einem das Leben mit Scala viel leichter. 
Es ist einfach natürlicher.

}
\end{frame}



\subsection*{Abschließende Worte}

\begin{frame}{Scala -- Meine Meinung}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Vorteile}
		\begin{itemize}
			\item<3->Für moderne Architekturen
			\item<4->Verständlich funktional
			\item<5->Java-Ökosystem
			\item<6->Macht Spaß
			\item<7->Statisch typisiert
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<8->
      \begin{block}{Nachteile}
		\begin{itemize}
			\item<9->Komplex
			\item<10->Zukunftssicher?
			\note<10->{Ich glaube ja, und mittlerweile ist es auch keine Nische mehr. Wenn man aber darauf angewiesen ist, dass eine Technologie auch in 10 Jahren noch genauso vorhanden ist (was wahrscheinlich schlecht ist), dann muss man vielleicht den an sich schlechteren Mainstream wählen. Scala ist aber bei weitem nicht mehr esoterisch.}
			\item<11->Anzahl Entwicklungssklaven
			\note<11->{Es gibt eine Lernkurve, man braucht Entwickler, die Spaß daran haben und die Vorteile sehen wollen.}
			\item<12->Binärkompatibilität nicht in alle Ewigkeit
			\note<12->{Ist besser geworden, insbes. mit Java 8. Die Scala-Macher sind aber nicht so konservativ wie Oracle. Aber wozu das führt, haben wir ja gesehen.}
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{Scala -- Einsatzgebiete}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Geeignet}
		\begin{itemize}
			\item<3->Akka
			\item<4->Moderne Architekturen auf der JVM
			\item<5->Tests für Java-Code
			\item<6->Hoher funtkionaler Anteil
			\item<7->Java ablösen, effizienter werden
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<8->
      \begin{block}{Weniger geeignet}
		\begin{itemize}
			\item<9->Scripting
			\item<10->Maschinennah
			\item<11->Spiele, Grafik, etc.
			\item<12->Man nutzt bereits F\# oder Swift
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{}
  \begin{quote}
		{\large We’ve found that Scala has enabled us to \alert{deliver things faster} with less code. It’s reinvigorated the team.}
		\vskip3mm
		\hspace*\fill{\small--- Graham Tackley, Guardian}
	\end{quote}
	\note{Der Guardian ist der Inbegriff für den Technologiewandel in einer klassischen, behäbigen Branche. Lange, bevor Springer wach geworden ist.}
\end{frame}

\begin{frame}{}
	\begin{block}{Literatur}
		\begin{itemize}
			\item<2->Heiko Seeberger: "`Durchstarten mit Scala. Tutorial für Einsteiger"'
			\note<2>{Sehr angenehmes Einsteigerbuch, das nur an der Oberfläche kratzt, aber genügend zeigt, um arbeiten zu können.}
			\item<3->Martin Odersky: "`Programming in Scala"'
			\note<3>{Unglaublich detaillierte Vorstellung des Schöpfers. Lest das nicht zuerst, es erschlägt.}
			% Todo: Mehr Referenzen, z.B. Präsentationen, Screencasts
		\end{itemize}
	\end{block}
	\note{Wie gesagt habe ich wenig Ahnung von Scala, da ich es noch nicht produktiv eingesetzt habe. Ich lasse mich aber gerne zwingen, 
für Interessierte ein Hands on durchzuführen, bei dem wir ein paar Stunden mit Scala in einer echten IDE spielen, nicht auf Folien.
Ich würde natürlich auch dafür aus Büchern klauen.

}
\end{frame}


% Abschlussfolie, leer und dunkel.
\plain{}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%
% Vorlagen
%%%%%%%%%%%%%%%%%%%%%%%
\appendix

% Notes
% Notes können innerhalb von Folien definiert und mit Overlays spezifiziert werden. Dann werden sie entsprechend zum Folienteil angezeigt.
% Nach der Folie definierte Notes werden der Folie zugeordnet, aber nur einmal - am Ende der Folie - ausgegeben.

% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


% Listing mit Header
\begin{frame}[fragile]{Primzahlen}
	\begin{block}{}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def swap(i: Int, j: Int) {
	val t = xs(i); xs(i) = xs(j); xs(j) = t
	()
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


% Großer Text
\begin{frame}{}
	\Large\textbf{}
	\note{}
\end{frame}


% Einfacher Block
\begin{frame}{}
	\begin{block}{}
		
	\end{block}
	\note{}
\end{frame}


% Aufzählung
\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Vergleich
\begin{frame}{}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


% Folie ausblenden
\begin{frame}<presentation:0>[fragile]{}
\end{frame}
