\documentclass[14pt,aspectratio=169]{beamer} %aspectratio=169 %aspectratio=43 % trans erzeugt Folien ohne Overlay
\usepackage[ngerman]{babel}
\usepackage[ansinew]{luainputenc}
\usepackage{listings}
\usepackage{pgfpages} % Second screen
\setbeameroption{hide notes} % show notes on second screen=bottom % hide notes % show notes % show only notes
\setbeamerfont{note page}{size=\tiny}


% Some colors
\definecolor{hBlue}{HTML}{004C99}
\definecolor{hBlack}{HTML}{555555}
\definecolor{hHeaderRed}{HTML}{E32119}
\definecolor{hBgLightBlue}{HTML}{E9E9E9}
\definecolor{hDarkBlue}{HTML}{00264C}

\definecolor{mDarkBrown}{HTML}{604c38}
\definecolor{mDarkTeal}{HTML}{23373b}
\definecolor{mLightBrown}{HTML}{EB811B}
\definecolor{mLightGreen}{HTML}{14B03D}

% Some styles for listings
\lstset{tabsize=2}
\lstdefinestyle{customscala}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Scala,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=none,
  xleftmargin=\parindent,
  language=Java,
  showstringspaces=false,
	numberstyle={\tiny},
  numbers=left,
  basicstyle=\footnotesize\ttfamily\color{black},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{hBlue},
  stringstyle=\color{orange},
}

\lstset{style=customscala}

\usetheme[progressbar=foot, 
					numbering=none, 
					background=light,
					block=transparent]{metropolis} % block:fill
\setsansfont[BoldFont={Fira Sans},ItalicFont={Fira Sans Light Italic}]{Fira Sans Light}
\metroset{sectionpage=none} %sectionpage=progressbar

\setbeamercolor{normal text}{fg=hBlue, bg=black!2}
\setbeamercolor{alerted text}{fg=hHeaderRed}
\setbeamercolor{example text}{fg=mLightGreen}
\setbeamercolor{titlelike}{use=normal text, parent=normal text}
\setbeamercolor{author}{use=normal text, parent=normal text}
\setbeamercolor{date}{use=normal text, parent=normal text}
\setbeamercolor{institute}{use=normal text, parent=normal text}
\setbeamercolor{structure}{use=normal text, fg=normal text.fg}
\setbeamercolor{palette primary}{use=normal text, fg=normal text.bg, bg=normal text.fg}
\setbeamercolor{frametitle}{use=palette primary, parent=palette primary}
\setbeamercolor{progress bar}{use=alerted text, fg=alerted text.fg, bg=alerted text.fg!50!black!30}
\setbeamercolor{title separator}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in head/foot}{use=progress bar, parent=progress bar}
\setbeamercolor{progress bar in section page}{use=progress bar, parent=progress bar}
%block transparent
\setbeamercolor{block title}{use=normal text, fg=hBlack, bg=}
\setbeamercolor{block body}{bg= }
\setbeamercolor{block body alerted}{use=block body, parent=block body}
\setbeamercolor{block body example}{use=block body, parent=block body}
\setbeamercolor{footnote}{fg=normal text.fg!90}
\setbeamercolor{footnote mark}{fg=.}

%% End color definition

% Subsectionpage
\AtBeginSubsection{\frame{\subsectionpage}}

\defbeamertemplate{subsection page}{progressbar}{
  \centering
  \begin{minipage}{22em}
    \raggedright
    \usebeamercolor[fg]{section title}
    \usebeamerfont{section title}
    \insertsectionhead\\[-1ex]
    \usebeamertemplate*{progress bar in section page}
    \par
    \ifx\insertsubsection\@empty\else%
      \usebeamercolor[fg]{subsection title}%
      \usebeamerfont{subsection title}%
      \insertsubsection
    \fi
  \end{minipage}
  \par
  \vspace{\baselineskip}
}

\setbeamertemplate{subsection page}[progressbar]
% End Subsectionpage

\usepackage{appendixnumberbeamer}
\usepackage[scale=2]{ccicons}
\usepackage{xspace}

\title{Scala (Programmiersprache)}
\subtitle{Ein Teaser und allgemeinere Gedanken}
\date{16. März 2016}
\author{Sebastian Eidecker}

\begin{document}

\maketitle

\begin{frame}{}
  \begin{quote}
		{\large Wer als Werkzeug nur einen Hammer hat,\\sieht in jedem Problem einen Nagel.}
		\vskip3mm
		\hspace*\fill{\small--- Paul Watzlawick}
	\end{quote}
\end{frame}
\note{
Ich möchte heute über Scala reden. Eigentlich will ich aber nicht nur über Scala reden.  Ich möchte nicht Scala verkaufen, sondern etwas völlig anderes. Scala ist spannend - für Nerds, die des Geldes wegen Java benutzen, denen aber mittlerweile Oracles Update-Politik nicht mehr gefällt. 
	
Ich will aber auch über aus meiner Sicht wichtigere Probleme reden. Und vielleicht passt Scala ja doch irgendwie.
	
In der IT wollen wir Probleme lösen und Möglichkeiten schaffen.
Ich bin der festen Überzeugung, dass wir zu selten über den Kern unserer Probleme nachdenken und auch, dass sich diese Probleme gerade ändern und immer schneller ändern werden.

Ich glaube daher, dass wir unser Problem \alert{und} unseren Werkzeugkasten kennen müssen. Ich glaube, dass wir zumindest wissen müssen, was im Baumarkt ausliegt und wir bei Bedarf einkaufen können. Daher kann es aus meiner Sicht nie schaden, sich neue Werkzeuge und Arbeitsweisen anzuschauen, damit man sie bei Bedarf zumindest im Hinterkopf hat. Sonst kann es passieren, dass wir das Problem gar nicht verstehen, weil wir kein passendes Werkzeug dafür besitzen und verwenden können.

}

\begin{frame}{}
	\setbeamertemplate{section in toc}[sections unnumbered]
	\begin{block}{Worüber reden wir?}
		\vskip2mm
		\onslide<1->{\tableofcontents[pausesections,pausesubsections]} %[hideallsubsections]}
	\end{block}
	\note{Deswegen, möchte ich über zwei Dinge reden: Neue Herausforderungen und Scala.}
\end{frame}


\section{IT im Wandel}


\subsection{Herausforderungen}

\begin{frame}{}
	\only<1>{\Large\textbf{Software Engineering}}\only<2>{\Large\textbf{Software \alert{Engineering}}}
	\note{Software Engineering. Passt der Begriff? Ich denke, dies impliziert zu stark, dass wir ein Problem nur lange genug durchdenken, exakt definieren und dann eine gute Lösung bauen müssen. Womöglich verstehe ich den Beruf des Ingenieurs falsch, aber ich glaube, wir haben gesehen, dass Software agil gebaut werden sollte, dass wir nicht zu Beginn eines Projektes alle Anforderungen exakt spezifizieren können. Und: Wir können kein System bauen, das hunderte Jahre stabil steht, wie eine Kirche oder Brücke. Wir müssen es ständig pflegen und verbessern, damit es nützlich bleibt.
	
}
\end{frame}


\begin{frame}{}
	\begin{block}{Forderungen an IT}
		\begin{itemize}
			\item<2->Stabilität und Resilienz
			\note<2>{Magnor: Sorgen sie durch ihre Arbeit dafür, dass Systeme Kriterien der Stabilität und Resilienz erfüllen.
			Seien sie "`dran"' an den Problemen, antizipieren sie sie, schaffen sie Fall-Back-Lösungen -- auch an Wochenenden.
			
			}
			\item<3->Wertbeitrag
			\note<3>{IT entwickelt sich zunehmend zu einem eigenen Produktionsfaktor (4-Sektor-Hypothese).
			Seien sie ein verlässlicher Partner für das Business, nehmen sie die Business-Seite auch an die Hand, helfen und unterstützen sie, leisten sie einen wahrgenommenen Wertbeitrag.[...]
			
			}
			\item<4->Businesstreiber
			\note<4>{Die Entwicklung der IT treibt zunehmend die Business-Seite und verändert Geschäftsmodelle.
			Seien sie an der Front und treiben sie das Business, entwickeln sie neue Ideen, forschen sie nach neuen Lösungen (Beispiele: Uber, 3D-Printing, CoLo21, ...
			
			}
		\end{itemize}
		\onslide<5->{\vskip3mm --- Matthias Magnor -- CEO Surface und Contract Logistics}
		\note<5->{Das Bewusstsein, dass ein Wandel stattfindet, ist im Business angekommen. Diese Forderungen stammen von Matthias Magnor!}
	\end{block}
\end{frame}


\subsection{Manifeste}
\note{Ein Manifest (lateinisch manifestus ‚handgreiflich gemacht‘) ist eine öffentliche Erklärung von Zielen und Absichten, oftmals politischer Natur. (Wikipedia)}

\begin{frame}{}
	\begin{block}{Manifeste}
		\begin{itemize}
			\item<2,5->Antwortbereit, Widerstandsfähig, Elastisch, Nachrichtenorientiert (2013)
			\note<2>{Reaktives Manifest}
			\item<3,5->Gut gefertigt, Stets Mehrwert, Gemeinschaft aus Experten, Produktive Partnerschaften (2009)
			\note<3>{Software Craftsmanship}
			\item<4,5->Individuen und Interaktionen, Funktionierende Software, Zusammenarbeit mit dem Kunden, Reagieren auf Veränderung (2001)
			\note<4>{Agiles Manifest}
		\end{itemize}
	\end{block}
\end{frame}
\note{Es gibt Manifeste von Softwareentwicklern, die sehr Ähnliches aussagen. (Reaktives Manifest, agiles Manifest, Manifest der Software Craftmanship-Bewegung als Beispiele) Diese sind bekannt und -- ich habe zumindest das Gefühl -- auch anerkannt. Ich will auch nur sehr kurz darauf eingehen, es soll ja vor allem um Scala gehen.

Im Grunde geht es überall darum, gemeinsam Software zu entwickeln, dabei die Bedürnisse des Kunden aktiv zu erforschen und möglichst zuverlässige und nützliche Software zu erstellen.
}
\begin{frame}{}
	\only<1->{\Large \textbf{Wo stehen wir?}}
	\note{Wie wollen wir uns positionieren, was müssen wir tun, um die Ziele zu erreichen bzw. unser Niveau zu halten? Hier kommt nun endlich Scala ins Spiel. Wir sollten so viele nützliche Tools wie möglich kennen, und ich denke, Scala ist eines der für uns interessanteren, was ich nun gleich hoffentlich zeigen kann.
	
	}
\end{frame}


\section{Scala}

\subsection{Management Summary}

\begin{frame}{}
	\Large\textbf{\alert{Sca}}lable \textbf{\alert{La}}nguage
	\only<2->{
	\vskip3mm
	\begin{quote}
		{\normalsize This means that Scala grows with you. You can play with it by typing \alert{one-line expressions} and observing the results. But you can also rely on it for \alert{large mission critical systems} [...]}
		\vskip3mm
		\hspace*\fill{\small--- www.scala-lang.org}
	\end{quote}
	}
	\note{Was bedeutet das? Scala ist sehr flexibel. Es vereint sehr viele Konzepte und ist im API-Design sehr stark. So sollen unterschiedlichste Szenarien und Anforderungen bedient werden. Schauen wir, ob das Versprechen gehalten wird.
	
	}
\end{frame}


\begin{frame}{}
	\begin{block}{Eigenschaften}
		\begin{itemize}
			\item<2->Objektorientiert
			\note<2>{Keine Primitive, wie in Java. Ein schönes Beispiel: Dort hat man per Autoboxing Komplexität eingeführt statt Schönheit. NullPointer bei Primitiven anyone?}
			\item<3->Funktional
			\item<4->Statisch typisiert mit Type Inference
			\note<4>{Aber Type Inference, wenn gewünscht}
			\item<5->Immutable by default
			\item<6->Gewohnte Syntax ("`Java ohne Semikolon"')
			\item<7->Ausdrucksstark (APIs/DSLs)
			\note<7>{Bei Java bricht man sich schon die Hände, will man ein Builder-Pattern rekursiv umsetzen oder eine fluent API}
			\item<8->Jung (2004, Hype 2011)
		\end{itemize}
	\end{block}
\end{frame}
\note{}

\begin{frame}{}
	\begin{block}{Versprechen}
	\begin{itemize}
		\item<2->Produktivitätssteigerung
		\item<3->Höhere Codequalität
		\item<4->Mehr Spaß
		\note<4>{REPL, habe ich mir für Java schon immer gewünscht. Wer hat keine Testklasse, um mal etwas auszuprobieren?}
		\item[]<5->\alert{durch}
		\item<5->Weniger Code
		\item<6->Höheres Abstraktionsniveau
		\item<7->Skalierbarkeit
	\end{itemize}
	\end{block}
\end{frame}
\note{Passt in unseren Entwicklungsprozess. Leichte Änderungen an Deployment etc.

}

\begin{frame}{}
	\begin{block}{Scala und die Java-Plattform}
		\begin{itemize}
			\item<2->Java-Bytecode, läuft auf JVM
			\item<3->Java-Bibliotheken nutzbar
			\item<4->Bekannte IDEs
			\note<4,5>{Wenn man schon eine neue Sprache lernt, wird man wenigstens bei IDE und Buildprozess abgeholt.}
			\item<5->Ähnliches Toolset, oft wiederverwendbar
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


\subsection{Ein wenig Code}
\note{Vieles geklaut von Wikipedia oder Heiko Seebergers Buch}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<2->
  \begin{lstlisting}
public class Person {
	private final String firstName;
	private final String lastName;
	public Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
					}
	public String getFirstName() {
			return firstName;
	}
	public String getLastName() {
			return lastName;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=14]
	@Override
	public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Person person = (Person) o;
			if (firstName != null ? 
					!firstName.equals(person.firstName) : 
					person.firstName != null) return false;
			if (lastName != null ? 
					!lastName.equals(person.lastName) : 
					person.lastName != null) return false;
			return true;
	}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Eine Java-Klasse}
\scriptsize
\lstset{style=customjava}
	\onslide<1->
	\begin{lstlisting}[firstnumber=27]
	@Override
	public int hashCode() {
			int result = firstName != null ? firstName.hashCode() : 0;
			result = 
					31 * result + (lastName != null ? lastName.hashCode() : 0);
			return result;
	}
}
	\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{}
	\Large\textbf{Businesslogik?}
	\note{Wo ist die Businesslogik versteckt? Ich gebe zu, das wird nur ein Beispiel, aber es zeigt symptomatisch eine Schwäche von Java: 
Java ist leicht verständlich, Änderungen werden aber immer non-breaking eingeführt und fühlen sich oft deplatziert an.
Scala hat den Vorteil, neuer zu sein und kennt die Schmerzen der Java-Entwickler. Daher sind viele Dinge eingebaut, die man sich schon lange wünscht 
oder Konzepte, die man eigentlich schon immer umsetzen wollte, wenn es denn nicht so lästig wäre.
(Immutable Objects, Lambdas, Generics, checked Exceptions als Beispiel)

Ein besonders lästiges Nicht-Feature-Feature sind in meinen Augen JavaBeans, wie wir sie gerade gesehen haben. Leicht verständlich, aber strikte Richtlinien durch Konvention. Und wehe, dein Framework mag die Namen Deiner Getter und Setter nicht.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Dasselbe in Scala}
\small
	\onslide<2->
  \begin{lstlisting}
case class Person(firstName:String, lastName:String)
	\end{lstlisting}
\end{block}
\note{Ja, nur ein Beispiel, ein besonders krasses. Aber dennoch ein alltägliches.}
\end{frame}



% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{Es wird funktional -- Quicksort}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def quickSort[A <% Ordered[A]](xs: List[A]): List[A] = xs match {
  case Nil     => xs
  case y :: ys => ys partition (_ <= y) match {
    case (l1, l2) => quickSort(l1) ++ (y :: quickSort(l2)) 
	}
}
	\end{lstlisting}
\end{block}
\note{Man sieht: Ausdrucksstark, aber auch nicht mehr so straight forward wie Java (vor 8). Scala ist beides: Sehr einfach und fast beliebig komplex. Und dieser Quicksort ist noch lange nicht das Ende der Möglichkeiten.

}
\end{frame}


\begin{frame}{}
	\Large\textbf{Schnelldurchlauf Scala -- \alert{Endlich!}}
	\note{Jetzt endlich ein Schnelldurchlauf durch einige grundlegende Features von Scala. Leider nur kurz, 
ich habe meine Zeit ja mit Management Summary und meiner politischen Agenda vertrödelt.
Alle Beispiele sind natürlich geklaut.

Also hier nur ein paar Dinge zum Grundverständnis und ein paar nette Sachen, die Java-Entwickler interessieren dürften.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Variablen -- val und var}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
var j = 3
j = 4
\end{lstlisting}
\onslide<3->
\begin{lstlisting}[firstnumber=3]
val k = 3
k = 4
\end{lstlisting}
\end{block}
\onslide<4->Compile-Fehler für k, da immutable
\onslide<5->
\begin{lstlisting}[firstnumber=5]
val k: Int = 3
	\end{lstlisting}
\note{val ist Default. Typen kann man auch angeben}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Methoden}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f = 3 * 2

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
def f(): Int = 3 * 2

	\end{lstlisting}
	\onslide<4->
  \begin{lstlisting}[firstnumber=3]
def f(i: Int) = 3 * i
	\end{lstlisting}
	\onslide<5->
  \begin{lstlisting}[firstnumber=4]
def f(i: Int) = {
	3 * i
}
	\end{lstlisting}
\end{block}
\note{Hier mal eine Methode. Mit = definiert. Methoden können mehr als in Java, dazu später.
Die Klammern kann man sich sparen, wenn 
Typen kann man angeben, muss es aber nicht, so lange der Compiler sie ermitteln kann. 
Bei öffentlichen Methoden sollte man es aber tun, dann hat der Nutzer auch eine reelle Chance.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Implizites return}
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    "B"
}
	\end{lstlisting}
\end{block}
\onslide<3->{Letzte Anweisung wird zurückgegeben, impliziter Typ String.}
\note{
Kein return, letzte Anweisung wird zurückgegeben. Alles hat einen Typen!
Die Methode ist statisch typisiert! Der Compiler kann den Typen der Rückgabe ermitteln: String -- Type Inference
Wenn wir wollen, können wir ihn deklarieren. Bei öffentlichen Methoden sollte man das auch tun.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Type Inference -- Any}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def f() = {
  if (something)
    "A"
  else
    1
}
	\end{lstlisting}
\end{block}
\onslide<3->
Erste gemeinsame Oberklasse, zur Not Any
\note{}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Unit}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def print(s: String): Unit = println(s)
	\end{lstlisting}
\end{block}
\note{Wollen wir mal wirklich nichts zurückgeben, so existiert der Typ Unit. Sinnvoll bei Methoden, die ausschließlich Seiteneffekte haben. Sollte also selten sein.

}
\end{frame}

\begin{frame}<presentation:0>[fragile]{}
 \begin{block}{Parameter sind vals}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def addOne(i: Int): Int = { i += 1; i }
	\end{lstlisting}
\end{block}
\onslide<3->Compile-Fehler, da i immutable
\note{i ist val per Default, also immutable. Letzter Ausdruck ist return}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Listen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val bagContent = List(1, "a", Time(12,30), 4)
	\end{lstlisting}
\end{block}
\onslide<4->
Immutable-Listen bevorzugen
\note{Einfache Erstellung von Listen. Type Inference auch hier, zweite ist Liste von Any. Collections gibt es immer auch Immutable, die auch schnell sind.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Funktionen höherer Ordnung}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbers = List(1, 2, 3, 4)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val numbersDecreasing = numbers.sortWith((x, y) => x > y)	
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusOne = numbers.map(x => x + 1)
\end{lstlisting}
\end{block}
\note{Funktionen können als Parameter übergeben werden. Auch die Funktion ist ein Objekt.
Kennt man in Java mittlerweile auch, wirkt aber aus meiner Sicht nicht so schön integriert.

}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Funktionen als Typen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val numbersPlusOne = numbers.map(x => x + 1)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber = 2]
val addTwo = (n: Int) => n + 2
\end{lstlisting}
\onslide<4->
  \begin{lstlisting}[firstnumber = 3]
val numbersPlusTwo = numbers.map(addTwo)

\end{lstlisting}
\onslide<5->
  \begin{lstlisting}[firstnumber = 4]
val descending = (n: Int, m: Int) => n > m
\end{lstlisting}
\onslide<6->
  \begin{lstlisting}[firstnumber = 5]
val sortedNumbers = numbers.sortWith(descending)
\end{lstlisting}

\end{block}
\note{Wir können Funktionen auch wie Variablen verwenden und übergeben. Es sind first class citizens. Und das ist mächtig. Das sehen wir schon in Java 8, aber in Scala war es schon immer und wird bereits fleißig in APIs genutzt. Das macht es für Programmierer, die keinen funktionalen Background haben, leider auch nicht einfacher. Methoden sind übrigens keine Objekte (Methode per def, Funktion per val deklariert.)
Methode in Funktion umwandeln
def addOne(n: Int) = n+1
val f = addOne \_

addOne kann dennoch übergeben werden, da Compiler die Arbeit übernimmt.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Klassen}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int, val minutes: Int) {
  // Primärer Konstruktor
  require(hours < 24 && hours >= 0)
  require(minutes < 60 && minutes >= 0)
	
	def this() = this(0)
}
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=8]
val t = new Time(1, 14)
val t2 = new Time
	\end{lstlisting}
\end{block}
\note{Der Standardkonstruktor für alle Parameter ist direkt im Methodenrumpf. Hilfskonstruktoren sind möglich.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Benannte Parameter und Standardwerte}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
class Time(val hours: Int = 0, val minutes: Int = 0)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val t = new Time(1)
val t2 = new Time(minutes = 13)
	\end{lstlisting}
\end{block}
\note{Damit werden Argumentnamen aber auch API-Bestandteil und dürfen nicht geändert werden.}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Singleton/Companion Objects}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
object Time {
	def fromMinutes(minutes: Int): Time = 
			new Time(minutes / 60, minutes % 60)
}

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val t = Time.fromMimutes(100)
	\end{lstlisting}
\end{block}
\note{Companion Objects sind Singleton Objects. Sie existieren nur ein mal. "`Ersatz"' für static, das es nicht gibt. Companion Objects (selber Name, selbes Paket, selbe Datei wie Klasse) können auf private Elemente der Klasse zugreifen

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Case classes}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Person(nachname: String, vorname: String)

	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}[firstnumber=5]
val ich = Person("Eidecker", "Sebastian")
val sohn = ich.copy(vorname = "Nils")
	\end{lstlisting}
\end{block}
\note{Case classes sind JavaBeans in schön. Nehmen die üblichen Dinge ab, die sowieso die IDE macht. Ideal als DTO, man kann/sollte aber nicht von ihnen erben. Hübscher "`Konstruktor"', Copy-Konstruktor und toString

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Vererbung und Traits}
\begin{itemize}
	\item<2->Geht
	\item<3->Mehrfachvererbung durch Traits
	\item<4->Zu wenig Zeit heute
\end{itemize}
\end{block}
\note{Ähnlich Java in den Grundzügen. Mit Traits Mehrfachvererbung möglich. Dadurch häufig kleinere Funktionsblöcke in Traits. Java 8 bietet mit default-Methoden in Interfaces ähnliches. Kann ich aber in der kurzen Zeit nicht sinnvoll motivieren.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Schönere Methodenaufrufe}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
"Test".startsWith("T")
List(1,2,3).isEmpty
	\end{lstlisting}
	\onslide<3->
  \begin{lstlisting}
"Test" startsWith "T"
List(1,2,3) isEmpty
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Definition eigener Operatoren}
\scriptsize
\begin{overlayarea}{\textwidth}{4cm}
	\begin{onlyenv}<2-4>
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}

}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<5->
	\begin{lstlisting}
case class Time(hour:Int, minute:Int) {
  def minus(time: Time) = {new Time(this.hour - time.hour, this.minute - time.minute)}
  def -(time: Time) = minus(time)
}
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<3>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))

			
	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<4-5>
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)

	\end{lstlisting}
	\end{onlyenv}
	\begin{onlyenv}<6->
  \begin{lstlisting}[firstnumber=5]
Time(10,20).minus(Time(1,10))
Time(10,20) minus Time(1,10)
Time(10,20) - Time(1,10)
	\end{lstlisting}
	\end{onlyenv}
	\end{overlayarea}
\end{block}
\note{}
\end{frame}


\begin{frame}[fragile]{}
 \begin{block}{Pattern Matching}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)
   
for (person <- List(alice, bob, charlie)) {
	person match {
		case Person("Alice", 25) => println("Hallo Alice!")
    case Person("Bob", 32) => println("Hallo Bob!")
    case Person(name, age) => println("Alter: " + alter + ", Name: " + name)
  }
}
	\end{lstlisting}
\end{block}
\note{Sehr mächtiges Feature. Code wirkt auf einmal sinnvoll. Java-Case auf Steroids ist noch zu schwach. Vielfältige Pattern möglich. Dabei Aufspalten von Listen möglich, siehe Quicksort.
Bekannt aus rein funktionalen Sprachen.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Pattern Matching -- Funktional Länge einer Liste}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
def length[A](list : List[A]) : Int = {
  list match {
    case _ :: tail => 1 + length(tail)
    case Nil => 0
  }
}
	\end{lstlisting}
\end{block}
\note{Liste wird in Head und tail getailt per :: Dann rekursiv weiter
Da fühlt sich der Compiler-Entwickler foch schon fast abgeholt.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Tupel}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
val ichMitAlter = (Person("Eidecker", "Sebastian"), 37)

	\end{lstlisting}
\onslide<3->
  \begin{lstlisting}[firstnumber=2]
val ich = ichMitAlter._1
val alter = ichMitAlter._2

	\end{lstlisting}	
	\onslide<4->
  \begin{lstlisting}[firstnumber=4]
def personMitAlter(person: Person, alter: Int): (Person, Int) = {
	(person, alter)
}
\end{lstlisting}
\end{block}
\note{Tupel können nützlich sein, wenn man mal kein neues Objekt erstellen will. Oder, wenn man Maps verwendet. Oder, wenn man Funktionen als Parameter übergibt. Oder, wenn man Compiler baut.

}
\end{frame}

\begin{frame}<presentation:0>[fragile]{}
 \begin{block}{??? -- Mein heimlicher Star}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case class Time(hour:Int, minute:Int) {

  def minus(time: Time) = ???
	
}
	\end{lstlisting}
\end{block}
\onslide<3->{Kompilierbar, aber nicht gefährlich.}
\note{Kompiliert, beim Aufruf aber Exception. Hilfreich, wenn man test first entwickelt. Dann jammert der Compiler nicht ständig.}
\end{frame}

\begin{frame}{}
	\Large\textbf{Und noch viel, viel mehr ...}
	\note{Insbesondere im Bereich der funktionalen Programmierung. Aber dafür haben wir leider keine Zeit, ich will ja noch etwas Spannendes erzählen.
	
	}
\end{frame}

\subsection{Spannendes}

\begin{frame}{}
	 \begin{block}{Domain Specific Languages}
			 \begin{itemize}
				 \item<2->Fachliche Abstraktion
				 \item<3->Verständlicher
				 \item<4->Entwicklung schwierig
				 \item<5->Einschränkungen vorhanden
				\note<5->{Gegenüber externen DSLs wie Xtext, die beliebige Syntax erlauben}
			 \end{itemize}
	 \end{block}
	 \note{}
\end{frame}


\begin{frame}<presentation:0>[fragile]{}
 \begin{block}{DSL -- Beispiel}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
100 PRINT "Distance " % 'dist % "km, " % "Velocity " % 'v % "km/s, " % "Fuel " % 'fuel
110 INPUT 'burn
120 IF ABS('burn) <= 'fuel THEN 150
130 PRINT "You don't have that much fuel"
140 GOTO 100
150 LET ('v := 'v + 'burn * 10 / ('fuel + 'mass))
	\end{lstlisting}
\end{block}
\note{Ist natürlich Quatsch, zeigt aber, was geht. Und wir kommen auch gleich }
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Scalatest}
\scriptsize
	\onslide<1->
  \begin{lstlisting}
"Creating a Time" should {
    "throw an IllegalArgumentException for hours less than 0 or greater equal 24" in {
      forAll("hours") { (hours: Int) =>
        whenever(hours < 0 || hours >= 24) {
          an[IllegalArgumentException] should be thrownBy Time(hours)
        }
      }
    }
  }
	\end{lstlisting}
\end{block}
\note{DSLs sind sinnvoll, wenn sie besser zum Ausdruck bringen, was in der Domäne beschrieben wird.

}
\end{frame}

\begin{frame}{}
	\begin{block}{Aktoren}
		\begin{itemize}
				\item<2->Nebenläufige Einheiten
				\item<3->Empfangen Nachrichten (Ereignisse)
				\item<4->Abarbeitung FIFO
				\item<5->Verhaltensänderung
				\item<6->Asynchrone Kommunikation mit Aktoren
			\end{itemize}
	\end{block}
	\note{Kommen wir zu etwas wirklich Spannenden. Ich habe davon zugegeben kaum Ahnung, finde es aber so interessant, dass ich es heute erzählen muss!
	
	The Actor Model, which was first proposed by Carl Hewitt in 1973 [5] and was improved, among others, by Gul Agha [6]. This model takes a different approach to concurrency, which should avoid the problems caused by threading and locking.

In the actor model, each object is an actor. This is an entity that has a mailbox and a behaviour. Messages can be exchanged between actors, which will be buffered in the mailbox. Upon receiving a message, the behaviour of the actor is executed, upon which the actor can: send a number of messages to other actors, create a number of actors and assume new behaviour for the next message to be received.

Of importance in this model is that all communications are performed asynchronously. This implies that the sender does not wait for a message to be received upon sending it, it immediately continues its execution. There are no guarantees in which order messages will be received by the recipient, but they will eventually be delivered.

A second important property is that all communications happen by means of messages: there is no shared state between actors. If an actor wishes to obtain information about the internal state of another actor, it will have to use messages to request this information. This allows actors to control access to their state, avoiding problems like the lost-update problem. Manipulation of the internal state also happens through messages.

Each actor runs concurrently with other actors: it can be seen as a small independently running process.

Das ist ähnlich der reinen Objektorientierung, aber komplett asynchron. Die Idee ist übrigens alt (1973) und schon lange, z.B. in Erlang im Einsatz. Momentan passen die Probleme aber.
	http://www.brianstorti.com/the-actor-model/
	
	
}
\end{frame}


\begin{frame}{}
	\begin{block}{Akka}
		\begin{itemize}
			\item<2->Aktoren
			\note<2>{Klar, sonst hätte es die vorherige Folie nicht gegeben.
			Actors give you:
Simple and high-level abstractions for concurrency and parallelism.
Asynchronous, non-blocking and highly performant event-driven programming model.
Very lightweight event-driven processes (several million actors per GB of heap memory).

}
			\item<3->Fehlertoleranz
			\note<3>{
    Supervisor hierarchies with "let-it-crash" semantics.
    Supervisor hierarchies can span over multiple JVMs to provide truly fault-tolerant systems.
    Excellent for writing highly fault-tolerant systems that self-heal and never stop.

}
			\item<4->Standort-Transparenz
			\note<4>{Everything in Akka is designed to work in a distributed environment: all interactions of actors use pure message passing and everything is asynchronous.}
			\item<5->Nachrichten-Persistenz
			\note<5>{Messages received by an actor can optionally be persisted and replayed when the actor is started or restarted. This allows actors to recover their state, even after JVM crashes or when being migrated to another node.
			
			}
			\item<6->Reaktiv laut Manifest
		\end{itemize}
	\end{block}
	\note{Was bringt uns das nun: Ziemlich viel von dem, was moderne verteilte Systeme leisten sollten.
	
	}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
case object PingMessage
case object PongMessage
case object StartMessage
case object StopMessage

class Ping(pong: ActorRef) extends Actor {
  var count = 0
  def incrementAndPrint { count += 1; println("ping") }
	\end{lstlisting}
\end{block}
\note{http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example
Nachrichten mit Case-Klassen, einfacher geht es nicht. Und typsicher, was mir persönlich gut gefällt.
Ein Aktor hat einen Zustand und vor allem eine receive-Methode.

}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Ping-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=9]
  def receive = {
    case StartMessage =>
        incrementAndPrint
        pong ! PingMessage
    case PongMessage => 
        incrementAndPrint
        if (count > 99) {
          sender ! StopMessage
          println("ping stopped")
          context.stop(self)
        } else {
          sender ! PingMessage
        }
  }
}
	\end{lstlisting}
\end{block}
\note{In der receive-Methode wird das Verhalten implementiert.
http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example}
\end{frame}

\begin{frame}[fragile]{}
 \begin{block}{Akka -- Pong-Aktor}
\scriptsize
	\onslide<1->
  \begin{lstlisting}[firstnumber=19]
class Pong extends Actor {
  def receive = {
    case PingMessage =>
        println("  pong")
        sender ! PongMessage
    case StopMessage =>
        println("pong stopped")
        context.stop(self)
  }
}
	\end{lstlisting}
\end{block}
\note{Und hier das Gegenstück:
Ein einfaches Beispiel, aber man sieht, wie hier Nachrichten ausgetauscht werden. Das soll hier aber keine Akka-Schulung sein, die ich auch nicht halten könnte, sondern
eine Idee geben, warum Scala geeignet sein könnte, Aktoren zu implementieren.

Aktoren, die Daten empfangen, evtl. Zustand halten, die Daten verarbeiten und Nachrichten weiterschicken.
Das ganze hochparallelisiert, die Nachrichten werden sicher gespeichert.
Ich kann mir nicht helfen, aber das liest sich für mich wie ein Business-Prozess. Den man beliebig zusammenstecken kann. Und er funktioniert dennoch, weil man in der Programmiersprache dasselbe macht wie in einem EPK oder BPMN-Modell. (Disclaimer: Ich habe es noch nicht viel weiter als bis zu diesem Niveau ausprobiert, aber Menschen, die es getan haben, stimmen darin überein).

Und mit Scala (vor allem Pattern Matching) bricht man sich bei der Implementierung auch nicht die Finger.

}
\end{frame}


% Großer Text
\begin{frame}{}
	\Large\textbf{Bedeutung?}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Was haben wir gesehen}
		\begin{itemize}
			\item<2->Start, Stop, Nachrichten, Zustand
			\item<3->Klingt verdächtig nach Prozessen
			\item<4->Nebenläufig, skalierbar, resilient durch Akka
			\item[]<5->
			\item<5->Mein Traum: Direkte Abbildung
			\item<6->Scheint machbar
			\item<7->Umgewöhnung
		\end{itemize}
	\end{block}
	\note{}
\end{frame}

\begin{frame}{}
	\begin{block}{Warum in Scala?}
		\begin{itemize}
			\item<2->Pattern Matching
			\item<3->Funktional
			\item<4->Weniger Code
			\item<5->Besser verständlich
		\end{itemize}
	\end{block}
	\note{Akka kann man auch mit Java umsetzen. Aber insbesondere das Pattern Matching macht einem das Leben mit Scala viel leichter. 
Es ist einfach natürlicher.

}
\end{frame}





\begin{frame}{Scala -- Meine Meinung}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<2->
      \begin{block}{Vorteile}
		\begin{itemize}
			\item<3->Für moderne Architekturen
			\item<4->Verständlich funktional
			\item<5->Java-Ökosystem
			\item<6->Macht Spaß
			\item<7->Statisch typisiert
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<8->
      \begin{block}{Nachteile}
		\begin{itemize}
			\item<9->Komplex
			\item<10->Zukunftssicher?
			\note<10->{Ich glaube ja, und mittlerweile ist es auch keine Nische mehr. Wenn man aber darauf angewiesen ist, dass eine Technologie auch in 10 Jahren noch genauso vorhanden ist (was wahrscheinlich schlecht ist), dann muss man vielleicht den an sich schlechteren Mainstream wählen. Scala ist aber bei weitem nicht mehr esoterisch.}
			\item<11->Anzahl Entwicklungssklaven
			\note<11->{Es gibt eine Lernkurve, man braucht Entwickler, die Spaß daran haben und die Vorteile sehen wollen.}
			\item<12->Binärkompatibilität nicht in alle Ewigkeit
			\note<12->{Ist besser geworden, insbes. mit Java 8. Die Scala-Macher sind aber nicht so konservativ wie Oracle. Aber wozu das führt, haben wir ja gesehen.}
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}


\begin{frame}{}
  \begin{quote}
		{\large We’ve found that Scala has enabled us to \alert{deliver things faster} with less code. It’s reinvigorated the team.}
		\vskip3mm
		\hspace*\fill{\small--- Graham Tackley, Guardian}
	\end{quote}
	\note{Der Guardian ist der Inbegriff für den Technologiewandel in einer klassischen, behäbigen Branche. Lange, bevor Springer wach geworden ist.}
\end{frame}

\begin{frame}{}
	\begin{block}{Mehr für Nerds}
		\begin{itemize}
			\item<2->Sprecht mich an
			\note<2>{Oder Jörn, er kennt Scala und vor allem Akka noch deutlich besser}
			\item<3->Hands on-Termin bei Interesse
			\note<3>{Wenn einige Lust haben, organisieren wir eine Coding-Session}
			\item<4->Heiko Seeberger: "`Durchstarten mit Scala. Tutorial für Einsteiger"'
			\note<4>{Sehr angenehmes Einsteigerbuch, das nur an der Oberfläche kratzt, aber genügend zeigt, um arbeiten zu können.}
			\item<5->Martin Odersky: "`Programming in Scala"'
			\note<5>{Unglaublich detaillierte Vorstellung des Schöpfers. Lest das nicht zuerst, es erschlägt.}
		\end{itemize}
	\end{block}
	\note{Wie gesagt habe ich wenig Ahnung von Scala, da ich es noch nicht produktiv eingesetzt habe. Ich lasse mich aber gerne zwingen, 
für Interessierte ein Hands on durchzuführen, bei dem wir ein paar Stunden mit Scala in einer echten IDE spielen, nicht auf Folien.
Ich würde natürlich auch dafür aus Büchern klauen.

}
\end{frame}


% Abschlussfolie, leer und dunkel.
\plain{}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%
% Vorlagen
%%%%%%%%%%%%%%%%%%%%%%%
\appendix

% Notes
% Notes können innerhalb von Folien definiert und mit Overlays spezifiziert werden. Dann werden sie entsprechend zum Folienteil angezeigt.
% Nach der Folie definierte Notes werden der Folie zugeordnet, aber nur einmal - am Ende der Folie - ausgegeben.

% Listing einfach
\begin{frame}[fragile]{}
 \begin{block}{}
\scriptsize
	\onslide<2->
  \begin{lstlisting}
		class
	\end{lstlisting}
\end{block}
\note{}
\end{frame}


% Listing mit Header
\begin{frame}[fragile]{Primzahlen}
	\begin{block}{}
		\scriptsize
		\onslide<2->
  \begin{lstlisting}
def swap(i: Int, j: Int) {
	val t = xs(i); xs(i) = xs(j); xs(j) = t
	()
}
	\end{lstlisting}
	\end{block}
	\note{}
\end{frame}


% Großer Text
\begin{frame}{}
	\Large\textbf{}
	\note{}
\end{frame}


% Einfacher Block
\begin{frame}{}
	\begin{block}{}
		
	\end{block}
	\note{}
\end{frame}


% Aufzählung
\begin{frame}{}
	\begin{block}{Titel}
		\begin{itemize}
			\item<2->
			\item<3->
			\item<4->
		\end{itemize}
	\end{block}
	\note{}
\end{frame}


% Vergleich
\begin{frame}{}
  \begin{columns}[T,onlytextwidth]
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
    \column{0.5\textwidth}
	  \onslide<+->
      \begin{block}{Titel}
		\begin{itemize}
			\item<+->
			\item<+->
			\item<+->
		\end{itemize}
	\end{block}
  \end{columns}
	\note{}
\end{frame}

